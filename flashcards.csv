type,topic,question,answer,options,correctOption,explanation
mc,"Lecture 2","Hva er forskjellen mellom et problem og en problem-instans innenfor algoritmer?",,"Et problem er vanskeligere √• l√∏se enn en problem-instans|Et problem er en generell beskrivelse, mens en problem-instans er et spesifikt tilfelle med konkrete inndata|Et problem krever alltid en algoritme, mens en problem-instans kan l√∏ses manuelt|Et problem har kun √©n l√∏sning, mens en problem-instans kan ha flere l√∏sninger",1,"Et problem er en generell beskrivelse av hva inndataene ser ut som og hva den √∏nskede utdataen skal v√¶re, for eksempel sortering av en liste. En problem-instans er et spesifikt tilfelle av problemet med konkrete inndata, som for eksempel listen [3, 9, 1, 42, 17]."
mc,"Lecture 2","Forklar hva asymptotisk notasjon brukes til i forbindelse med algoritmeanalyse.",,"For √• m√•le n√∏yaktig kj√∏retid i sekunder for alle typer algoritmer|For √• analysere hvordan kj√∏retiden oppf√∏rer seg|For √• telle antall linjer kode i en algoritme|For √• sammenligne konstante faktorer mellom algoritmer",1,"Asymptotisk notasjon er et verkt√∏y for √• analysere hvordan kj√∏retiden til en algoritme (eller veksten til en matematisk funksjon) oppf√∏rer seg n√•r st√∏rrelsen p√• inndataene blir veldig stor. Det hjelper oss med √• sammenligne effektiviteten til forskjellige algoritmer ved √• fokusere p√• den dominerende veksttermen og ignorere konstante faktorer og lavere ordens termer."
qa,"Lecture 2","Nevn og beskriv kort de tre hovedkategoriene av asymptotisk notasjon som ble presentert.","Big-O notasjon (ùëÇ) gir en √∏vre grense for veksten til en funksjon; ùëì(ùëõ) = ùëÇ(ùëî(ùëõ)) betyr at ùëì ikke vokser raskere enn ùëî. Big-omega notasjon (Œ©) gir en nedre grense; ùëì(ùëõ) = Œ©(ùëî(ùëõ)) betyr at ùëì ikke vokser saktere enn ùëî. Big-theta notasjon (Œò) betyr at to funksjoner vokser i samme takt; ùëì(ùëõ) = Œò(ùëî(ùëõ)) betyr at ùëì og ùëî har samme vekstrate.",,,
qa,"Lecture 2","Hva er den typiske strukturen som kjennetegner sorteringsalgoritmer med kvadratisk tidskompleksitet?","Kvadratiske sorteringsalgoritmer har typisk to n√∏stede l√∏kker der begge l√∏kkene itererer over (omtrent) alle elementene i inndataene. Dette resulterer i et antall operasjoner som er proporsjonalt med kvadratet av inndatast√∏rrelsen (ùëõ¬≤).",,,
qa,"Lecture 2","Hvorfor har sammenligningsbaserte sorteringsalgoritmer en nedre grense p√• Œ©(ùëõ log ùëõ) i verste fall?","Sammenligningsbaserte sorteringsalgoritmer bestemmer rekkef√∏lgen av elementer kun ved √• sammenligne par av elementer. Det er bevist at i verste fall kreves det minst logaritmen av antall mulige permutasjoner (som er ùëõ!) for √• garantere at listen er sortert, og log‚ÇÇ(ùëõ!) er i Œ©(ùëõ log ùëõ).",,,
qa,"Lecture 2","Gi et eksempel p√• en operasjon som ikke regnes som et primitivt steg i kompleksitetsanalyse og forklar hvorfor.","Sammenligning eller konkatenering av strenger regnes vanligvis ikke som et primitivt steg. Dette er fordi operasjonene kan ta en tid som er proporsjonal med lengden p√• strengene, og dermed ikke en konstant tidsbruk uavhengig av inndatast√∏rrelsen.",,,
qa,"Lecture 2","Hva er et viktig hensyn √• ta n√•r man analyserer tidskompleksiteten til kode som bruker bibliotekfunksjoner?","N√•r man analyserer kode med bibliotekfunksjoner, er det viktig √• kjenne til (eller unders√∏ke) tidskompleksiteten til disse funksjonene. En enkelt linje kode som kaller en bibliotekfunksjon kan skjule en ikke-konstant tidsoperasjon, noe som p√•virker den totale kompleksiteten til algoritmen.",,,
qa,"Lecture 2","Beskriv ""bad painter's algorithm"" i forbindelse med strengkonkatenering i spr√•k med immutable strings.","""Bad painter's algorithm"" refererer til ineffektiv gjentatt konkatenering av strenger i spr√•k der strenger er immutable. Hver konkatenering skaper en ny streng og kopierer innholdet fra de gamle strengene, noe som f√∏rer til en kvadratisk tidskompleksitet (Œò(ùëõ¬≤)) hvis man gjentatte ganger legger til sm√• strenger til en stadig voksende streng.",,,
qa,"Lecture 2","Hva er den grunnleggende ideen bak amortisert tidskompleksitet, og i hvilke situasjoner kan det v√¶re en ulempe?","Amortisert tidskompleksitet beskriver den gjennomsnittlige kostnaden per operasjon over en sekvens av operasjoner, selv om enkelte individuelle operasjoner kan ha en h√∏yere kostnad. Dette oppst√•r ofte n√•r man dynamisk endrer st√∏rrelsen p√• datastrukturer, som for eksempel ved √• doble st√∏rrelsen p√• en array n√•r den er full. I sanntidssystemer med strenge tidsbegrensninger kan den variable kj√∏retiden til individuelle operasjoner v√¶re problematisk.",,,
qa,"Lecture 2","Nevn to eksempler p√• velkjente algoritmer eller datastrukturer (uten √• beskrive hvordan de fungerer) og forklar kort hvilke problemer de l√∏ser.","Et balansert bin√¶rt s√∏ketre er en datastruktur som tillater effektiv s√∏king, innsetting og sletting av elementer i logaritmisk tid. Dijkstras algoritme er en algoritme for √• finne den korteste stien fra en gitt startnode til alle andre noder i en vektet graf uten negative kantvekter.",,,
qa,"Lecture 3","Hva er en hashmap, og hvordan oppn√•r den ""nesten konstant"" tidskompleksitet for mange operasjoner?","En hashmap er en datastruktur som lagrer n√∏kler og tilh√∏rende verdier. Den bruker en hashfunksjon for √• beregne en indeks i et internt array basert p√• n√∏kkelen, noe som gir rask tilgang, innsetting og sletting i forventet konstant tid, selv om kollisjoner kan p√•virke ytelsen i verste fall.",,,
qa,"Lecture 3","Hvorfor er det viktig √• implementere __hash__ og __eq__ (i Python) eller hashCode() og equals() (i Java) n√•r man bruker egendefinerte k","Disse metodene er essensielle for at hashmaps skal fungere korrekt med egendefinerte n√∏kler. __hash__/hashCode() bestemmer hvor objektet skal plasseres, mens __eq__/equals() brukes til √• sjekke om to n√∏kler er like, spesielt ved kollisjoner. Konsistens mellom disse to er avgj√∏rende: like objekter m√• ha samme hashkode",,,
qa,"Lecture 3","Beskriv hvordan dybde-f√∏rst s√∏k (DFS) fungerer for √• traversere en graf.","DFS fungerer ved √• starte ved en node, bes√∏ke en av dens ubes√∏kte naboer, og deretter rekursivt fortsette fra den naboen. Den utforsker en ""sti"" s√• dypt som mulig f√∏r den backtracker til forrige node og utforsker en annen sti. For √• unng√• uendelige l√∏kker i grafer med sykluser, m√• algoritmen markere bes√∏kte noder.",,,
qa,"Lecture 3","Hva er hovedproblemet med en rekursiv implementasjon av DFS for sv√¶rt store grafer eller tr√¶r, og hvordan kan man omg√• dette problemet?","En rekursiv DFS-implementasjon kan f√∏re til stack overflow errors for store grafer eller tr√¶r fordi hvert rekursive kall legger til et nytt lag i call stacken, som har begrenset st√∏rrelse. Dette kan unng√•s ved √• implementere DFS iterativt ved hjelp av en eksplisitt stack data struktur (som en liste eller en dedikert stack-klasse) som administreres p√• heapen, som har mye st√∏rre kapasitet.",,,
qa,"Lecture 3","Forklar konseptet memoization og gi et eksempel p√• n√•r det er spesielt nyttig.","Memoization er en optimaliseringsteknikk for rekursive funksjoner der resultatet av kostbare funksjonskall lagres og gjenbrukes for samme input. Det er nyttig for problemer med overlappende subproblemer, for eksempel beregning av Fibonacci-tall rekursivt, der mange delberegninger gj√∏res flere ganger.",,,
qa,"Lecture 3","Gi et kort eksempel p√• en listekomprenasjon i Python og forklar dens tidskompleksitet i forhold til antall elementer den opererer p√•. Eksempel: [x*2 for x in numbers if x > 0].","Denne listekomprenasjonen g√•r gjennom alle elementene i numbers. Hvis betingelsen x > 0 er sann, utf√∏res transformasjonen x*2 og resultatet legges til i den nye listen. Hvis det er n elementer i numbers, og betingelsen og transformasjonen tar konstant tid, vil tidskompleksiteten v√¶re Œò(n).",,,
qa,"Lecture 3","Hva er dynamisk programmering (DP), og hvordan skiller det seg fra memoization i implementeringen?","Dynamisk programmering er en teknikk for √• l√∏se komplekse problemer ved √• bryte dem ned i overlappende subproblemer, l√∏se hvert subproblem bare √©n gang og lagre l√∏sningene i en tabell. Mens memoization typisk er en top-down tiln√¶rming (rekursivt med lagring), er DP ofte en bottom-up tiln√¶rming (iterativt, starter med de enkleste subproblemene).",,,
qa,"Lecture 3","Hvilken viktig egenskap kjennetegner NP-komplette problemer med hensyn til verifisering av en foresl√•tt l√∏sning?","En viktig egenskap ved NP-komplette problemer er at selv om det kan v√¶re vanskelig √• finne en l√∏sning, kan korrektheten av en gitt ""ja""-l√∏sning verifiseres i polynomisk tid. Dette betyr at hvis noen presenterer en mulig l√∏sning, kan vi relativt raskt sjekke om den faktisk er gyldig.",,,
qa,"Lecture 3","Nevn to eksempler p√• NP-komplette beslutningsproblemer som ble nevnt i kildematerialet.","To eksempler p√• NP-komplette beslutningsproblemer er Boolean satisfiability (SAT) og Subset sum. Andre inkluderer Subgraph isomorphism og Traveling salesperson.",,,
qa,"Lecture 3","Hva er den viktigste fordelen med generatorkomprehensjoner i Python og stream expressions i Java sammenlignet med listekomprenhensjoner n√•r det gjelder minnebruk og ytelse i visse situasjoner?","Generatorkomprehensjoner og stream expressions er ""lazy evaluated"", noe som betyr at de genererer elementer kun n√•r de ettersp√∏rres, i stedet for √• lage hele datastrukturen p√• forh√•nd. Dette kan v√¶re mer minneeffektivt, spesielt for store datasett, og kan forbedre ytelsen hvis ikke alle genererte elementene faktisk brukes.",,,
mc,"Lecture 4","Hvilken av f√∏lgende beskrivelser stemmer best for hvordan datamaskinens minne fremst√•r for et program?",,"En samling av ustrukturerte data uten spesifikke adresser.|En hierarkisk struktur organisert i segmenter med ulike form√•l.|En sammenhengende sekvens av bytes, der hver byte har sin egen adresse|Et abstrakt konsept uten direkte korrespondanse til fysisk maskinvare.",2,"For et program fremst√•r datamaskinens minne som en kontinuerlig rekke av bytes, hvor hver byte har sin egen unike adresse. Programmet er ansvarlig for √• tolke innholdet i disse bytene og holde styr p√• hvilken type data som er lagret hvor, samt hvor de ulike verdiene begynner og slutter. \n\nAlternativ 'En samling' er feil fordi minnet er adressert. \nAlternativ 'En hierarkisk' kan delvis v√¶re sant p√• et operativsystemniv√• med for eksempel segmentering, men for det enkelte programmet er det mer korrekt √• se det som en line√¶r sekvens. \nAlternativ 'Et abstrakt' er feil fordi minnet er fysisk maskinvare som programmet direkte interagerer med gjennom adresser."
mc,"Lecture 4","Hvor skjer automatisk minneallokering hovedsakelig?",,"P√• stakken for lokale variabler og funksjonsparametere|P√• heapen ved bruk av new-operatoren|I statisk allokert minne for globale variabler|I virtuelt minne administrert av operativsystemet",0,"Automatisk minneallokering skjer p√• stakken. N√•r en funksjon kalles, opprettes en stack frame som inneholder funksjonens parametere og lokale variabler. Denne allokeringen og deallokeringen skjer automatisk n√•r funksjonen henholdsvis kalles og returnerer. \n\nAlternativ 'P√• heapen' beskriver dynamisk minneallokering som foreg√•r p√• heapen ved bruk av new.\nAlternativ 'I statisk' beskriver statisk minneallokering for globale variabler.\nAlternativ 'I virtuelt' refererer til en minneh√•ndteringsteknikk p√• operativsystemniv√•, ikke en spesifikk plassering for automatisk allokering sett fra programmet."
mc,"Lecture 4","Hvilken operator i C++ brukes for √• f√• tilgang til verdien som en peker peker p√•?",,"&|.|->|**",3,"Operatoren som brukes for √• f√• tilgang til (hente verdien fra) minneadressen som en peker inneholder, kalles dereferanseoperatoren, og i C++ er dette *.\n\nAlternativ &, er adresseoperatoren som gir deg minneadressen til en variabel.\nAlternativ ., brukes for √• f√• tilgang til medlemmer av et objekt direkte.\nAlternativ ->, brukes for √• f√• tilgang til medlemmer av et objekt gjennom en peker til objektet."
mc,"Lecture 4","Hva er hoved√•rsaken til at en stack overflow kan oppst√•?",,"For mange dynamiske minneallokeringer p√• heapen.|Fors√∏k p√• √• dereferere en nullpeker.|For mange nestede eller rekursive funksjonskall som bruker opp all tilgjengelig minne i stakken|Fragmentering av minnet p√• heapen.",2,"En stack overflow oppst√•r n√•r call stacken blir full. Dette skjer typisk ved for mange nestede funksjonskall eller dype rekursive kall som gj√∏r at det allokeres for mange stack frames. Hver funksjonskall legger til en ny stack frame som inneholder parametere, lokale variabler og returadresse. Hvis disse kallene ikke returnerer i tide, vil stakken til slutt g√• tom for plass.\n\nAlternativ 'For mange dynamiske' handler om heapen.\nAlternativ 'Fors√∏k p√• √• dereferere' f√∏rer til et programkrasj p√• grunn av ugyldig minnetilgang, ikke n√∏dvendigvis en stack overflow.\nAlternativ 'Fragmentering' er et problem knyttet til minneh√•ndtering p√• heapen."
mc,"Lecture 4","Hva er en av hovedgrunnene til √• bruke pekere i programmering?",,"For √• unng√• √• jobbe direkte med minneadresser.|Fordi det er den eneste m√•ten √• deklarere variabler i C++.|For at en funksjon skal kunne modifisere den underliggende verdien av en variabel som er passert som argument|For √• sikre at all minneallokering skjer statisk.",2,"En viktig grunn til √• bruke pekere er muligheten for at en funksjon kan direkte endre verdien av en variabel som er sendt inn som et argument . Uten pekere ville funksjoner som regel jobbet med kopier av argumentene. Pekere tillater ogs√• mer effektiv h√•ndtering av store objekter ved √• sende en adresse i stedet for √• kopiere hele objektet . Videre er pekere essensielle for √• lage dynamiske datastrukturer som lenkede lister .\n\nAlternativ 'For √• unng√•' er feil, da pekere er direkte arbeid med minneadresser.\nAlternativ 'Fordi det er' er feil; det finnes mange m√•ter √• deklarere variabler uten pekere.\nAlternativ 'For √• sikre' er feil; pekere brukes ofte i forbindelse med dynamisk minneallokering."
qa,"Lecture 4","Forklar forskjellen mellom big endian og little endian.","Big endian betyr at byten med st√∏rst signifikans lagres f√∏rst i minnet (ved den laveste adressen), mens little endian betyr at byten med minst signifikans lagres f√∏rst.\nFor en 4-byte integer vil rekkef√∏lgen av bytene i minnet v√¶re omvendt mellom de to endianess-typene",,,
qa,"Lecture 4","Hva er en nullpeker i C++ og hvorfor kan den v√¶re farlig?","En nullpeker er en peker som ikke peker p√• et gyldig minneomr√•de. Den representeres som NULL eller nullptr i C++. Den er farlig fordi fors√∏k p√• √• dereferere (f√• tilgang til verdien som pekeren ""peker"" p√•) en nullpeker kan f√∏re til at programmet krasjer.",,,
qa,"Lecture 4","Beskriv hvordan dynamisk minne allokeres i C++ og hva new-operatoren returnerer.","I C++ allokerer man dynamisk minne ved √• bruke new-operatoren fulgt av typen man √∏nsker √• allokere, for eksempel new int eller new Person(...). new-operatoren returnerer en peker til det nylig allokerte minnet.",,,
qa,"Lecture 4","Hva er heapen og hvordan skiller den seg fra stakken med tanke p√• minneallokering og deallokering?","Heapen er et minneomr√•de for dynamisk allokerte verdier. I motsetning til stakken, som har en streng LIFO-struktur (sist inn, f√∏rst ut), kan verdier p√• heapen allokeres og deallokeres i vilk√•rlig rekkef√∏lge, noe som kan f√∏re til fragmentering. Stakken brukes for automatisk minneallokering av lokale variabler og funksjonsparametere n√•r en funksjon kalles.",,,
qa,"Lecture 4","Hvordan h√•ndteres konseptet ""referanse til ingenting"" i C++, Java og Python?","I C++ representeres en ""referanse til ingenting"" av en nullpeker (NULL eller nullptr). En C++-referanse i seg selv m√• initialiseres til √• referere til en eksisterende variabel og kan ikke v√¶re null. I Java representeres en ""referanse til ingenting"" med n√∏kkelordet null. I Python finnes ikke nullpekere; i stedet brukes objektet None for √• indikere en manglende referanse. Fors√∏k p√• √• bruke en nullpeker (C++) eller en nullreferanse (Java) kan f√∏re til programkrasj eller exceptions.",,,
qa,"Lecture 5","Hva er hovedforskjellen p√• hvordan minne allokeres for arrays i C++ og Java?","I C++ allokeres arrays opprettet med new p√• heapen, og array-variabelen er en peker til det f√∏rste elementet. I Java allokeres arrays alltid p√• heapen, og array-variabelen er en referanse til arrayen.",,,
qa,"Lecture 5","Hva er en minnelekkasje i C++?","En minnelekkasje i C++ oppst√•r n√•r dynamisk allokert minne med new (eller new[]) ikke blir frigjort med delete (eller delete[]) n√•r det ikke lenger er i bruk. Dette resulterer i at programmet gradvis bruker mer minne.",,,
qa,"Lecture 5","Hva er garbage collection og hva er en av dens viktigste fordeler?","Garbage collection er en automatisk minneh√•ndteringsteknikk der systemet periodisk identifiserer og frigj√∏r minne som ikke lenger er referert til av programmet. En viktig fordel er at den reduserer byrden for programmereren ved √• h√•ndtere minnefrigj√∏ring automatisk.",,,
qa,"Lecture 5","Hva er en destrukt√∏r i C++ og n√•r blir den kalt?","En destrukt√∏r i C++ er en spesiell medlemsfunksjon i en klasse med samme navn som klassen, men med en tilde (~) foran. Den kalles automatisk n√•r et objekt av klassen g√•r ut av scope eller blir deallokert med delete eller delete[].",,,
qa,"Lecture 5","Forklar kort hva romlig lokalitet er.","Romlig lokalitet refererer til tendensen til et program √• aksessere minnelokasjoner som er n√¶re hverandre i minnet innenfor en kort tidsperiode. CPU-cacher utnytter dette ved √• lagre n√¶rliggende data sammen.",,,
qa,"Lecture 5","Hvorfor kan sortering av data noen ganger f√∏re til raskere utf√∏relse av kode med betingelser i l√∏kker?","Sortering kan forbedre ytelsen fordi hvis de fleste elementene som oppfyller en betingelse kommer sammen, vil branch prediction i CPUen ha lettere for √• korrekt forutsi utfallet av betingelsen. Dette reduserer antall feilaktige forutsigelser og forbedrer dermed utf√∏relsestiden.",,,
mc,"Lecture 5","Hvor allokeres minne for arrays som opprettes dynamisk i C++?",,"P√• stakken.|P√• heapen|I statisk minne.|I CPU-cachen.",1,"I C++, arrays opprettet med new allokeres p√• heapen. \nStakken brukes hovedsakelig for lokale variabler og funksjonskall.\nStatisk minne brukes for globale variabler og variabler deklarert som static.\nCPU-cachen er et hurtigminne for nylig brukte data, ikke et sted for prim√¶r minneallokering."
mc,"Lecture 5","Hvilket av f√∏lgende er hovedform√•let med en destrukt√∏r i C++?",,"√Ö allokere minne for et objekt.|√Ö initialisere medlemsvariablene til et objekt.|√Ö frigj√∏re ressurser som et objekt har allokert.|√Ö definere grensesnittet til et objekt.",2,"Den prim√¶re form√•let med en destrukt√∏r i C++ er √• frigj√∏re ressurser, som for eksempel dynamisk allokert minne, som objektet har brukt.\nAllokering av minne gj√∏res vanligvis med konstrukt√∏rer eller new.\nInitialisering av medlemsvariabler er ogs√• en vanlig oppgave for konstrukt√∏rer.\n√Ö definere grensesnittet gj√∏res gjennom klassedeklarasjonen."
mc,"Lecture 5","Hva er den potensielle ulempen med garbage collection sammenlignet med manuell minneh√•ndtering?",,"St√∏rre risiko for minnelekkasjer.|Mer kompleks kode for minneh√•ndtering.|Potensielle korte pauser i utf√∏relsen.|Vanskeligere √• utnytte cache-lokalitet.",2,"En ulempe med garbage collection er potensielle korte pauser i utf√∏relsen mens s√∏ppelinnsamleren kj√∏rer.\n\nManuell minneh√•ndtering i C++ kan f√∏re til st√∏rre risiko for minnelekkasjer hvis det ikke gj√∏res korrekt.\nKompleksiteten ligger i √• h√•ndtere minnet selv, ikke n√∏dvendigvis i garbage collection.\nUtnyttelse av cache-lokalitet er mer relatert til hvordan data struktureres og aksesseres, ikke prim√¶rt til minneh√•ndteringsmetoden."
mc,"Lecture 5","Hva menes med tidslig lokalitet",,"Tendensen til √• aksessere minnelokasjoner som er langt fra hverandre i minnet.|Tendensen til √• aksessere minnelokasjoner i en bestemt rekkef√∏lge.|endensen til √• aksessere den samme minnelokasjonen flere ganger innenfor en kort tidsperiode.|Tendensen til √• allokere minne kun p√• stakken.",2,"Tidslig lokalitet refererer til tendensen til √• aksessere den samme minnelokasjonen flere ganger innenfor en kort tidsperiode. \nAlternativ 'minnelokasjoner som er langt fra hverandre' beskriver mangel p√• romlig lokalitet.\nAlternativ 'minnelokasjoner i en bestemt rekkef√∏lge' beskriver et aksessm√∏nster, men ikke n√∏dvendigvis tidslig lokalitet. \nAlternativ 'Tendensen til √• allokere' handler om minneallokering p√• stakken, ikke lokalitet."
mc,"Lecture 5","Hvorfor kan det oppst√• minnelekkasjer i spr√•k som bruker garbage collection?",,"Fordi garbage collectoren ikke fungerer korrekt.|Fordi minne allokert p√• stakken ikke blir frigjort.|Fordi programmet beholder referanser til objekter som ikke lenger er n√∏dvendige|Fordi destrukt√∏rer ikke kalles automatisk.",2,"Minnelekkasjer kan oppst√• selv med garbage collection hvis programmet beholder referanser til objekter eller arrays som ikke lenger er n√∏dvendige. Garbage collectoren frigj√∏r kun minne som ikke har noen aktive referanser. \n\nAlternativ ' ikke fungerer korrekt.' er usannsynlig i velfungerende systemer.\nAlternativ 'minne allokert p√• stakken ikke blir frigjort.' er ikke en typisk √•rsak til lekkasjer i spr√•k med garbage collection. \nAlternativ 'destrukt√∏rer ikke kalles' er relevant for C++, der manglende destrukt√∏rer kan f√∏re til ressurslekkasjer, men i spr√•k med garbage collection er problemet snarere at objektene fortsatt er ""i bruk"" s√• lenge det finnes referanser til dem."
mc,"Lecture 5","Hvilken konsekvens kan det ha √• aksessere en multidimensjonal array p√• en m√•te som ikke er cache-vennlig?",,"Raskere programutf√∏relse p√• grunn av mindre minnebruk.|Tregere programutf√∏relse p√• grunn av d√•rligere utnyttelse av CPU-cachen. |√òkt risiko for minnelekkasjer.|Kompilatoren vil optimalisere aksessm√∏nsteret automatisk.",1,"√Ö aksessere en multidimensjonal array p√• en ikke cache-vennlig m√•te kan f√∏re til tregere programutf√∏relse p√• grunn av d√•rligere utnyttelse av CPU-cachen. N√•r aksessm√∏nsteret ikke f√∏lger den fysiske layouten i minnet, vil CPUen oftere m√•tte hente data fra hovedminnet i stedet for den raskere cachen. Dette √∏ker minnetilgangstiden og reduserer ytelsen. \n\nAlternativ 'Raskere programutf√∏relse' er feil da d√•rlig cache-bruk vanligvis ikke reduserer minnebruken. \nAlternativ '√òkt risiko' er ikke direkte relatert til cache-bruk. \nAlternativ 'Kompilatoren ' er ikke alltid tilfelle; programmereren m√• ofte ta hensyn til cache-effektivitet i koden."
qa,"Lecture 6","Hva er hovedforskjellen p√• hvordan bibliotekkode inkluderes ved statisk og dynamisk linking?","Ved statisk linking kopieres bibliotekkoden direkte inn i den kj√∏rbare filen under kompilering. Ved dynamisk linking lagres bibliotekskoden i separate delte bibliotekfiler, og operativsystemet laster dem inn i minnet n√•r programmet kj√∏rer.",,,
qa,"Lecture 6","Nevn √©n fordel med statisk linking og √©n fordel med dynamisk linking.","En fordel med statisk linking er at den kj√∏rbare filen inneholder all n√∏dvendig kode og dermed er mer portabel. En fordel med dynamisk linking er at diskplass spares fordi delte biblioteker bare lagres √©n gang.",,,
qa,"Lecture 6","Hvilke tre standardstr√∏mmer stiller operativsystemet til r√•dighet for en prosess, og hva er deres prim√¶re bruksomr√•der?","De tre standardstr√∏mmene er stdin (standard input) for inndata til programmet (vanligvis tastatur), stdout (standard output) for normal utdata fra programmet (vanligvis terminal), og stderr (standard error) for feilmeldinger fra programmet (ogs√• vanligvis terminal).",,,
qa,"Lecture 6","Hva indikerer en statuskode p√• 0 n√•r et program avsluttes i henhold til Linux-konvensjonen, og hvordan kan man spesifisere en annen statuskode i Python?","En statuskode p√• 0 indikerer at programmet ble utf√∏rt uten feil. I Python kan man spesifisere en annen statuskode ved √• bruke sys.exit(x) hvor x er den √∏nskede koden.",,,
qa,"Lecture 6","Forklar kort hensikten med `extern ""C""` i C++.","Hensikten med `extern ""C""` i C++ er √• hindre navnemangling (name mangling) for spesifikke funksjoner. Dette gj√∏r at C++-funksjoner kan kalles fra C-kode eller andre spr√•k som forventer C-stil funksjonsnavn.",,,
qa,"Lecture 6","Hva er Java Native Interface (JNI) og hva er Foreign Function & Memory API (FFM API) i Java?","Java Native Interface (JNI) er en mekanisme som gj√∏r det mulig for Java-kode √• samhandle med kode skrevet i andre spr√•k som C og C++. Foreign Function & Memory API (FFM API) er et nyere system i Java som forenkler interaksjonen med kode utenfor JVM.",,,
mc,"Lecture 6","Hvilket begrep beskriver prosessen der bibliotekkode kopieres direkte inn i den kj√∏rbare filen under kompilering?",,"Dynamisk linking|Statisk linking|Lasting|Kompilering",1,"Statisk linking er definert som prosessen der kompilatoren kopierer og kombinerer all n√∏dvendig bibliotekkode direkte inn i den endelige kj√∏rbare filen under kompilering.\n\nAlternativ 'Dynamisk linking' refererer til at koblingen til bibliotekkode utsettes til kj√∏retid. \nAlternativ 'Lasting' er prosessen der operativsystemet henter den kj√∏rbare filen (og eventuelle dynamiske biblioteker) inn i minnet ved kj√∏retid. \nAlternativ 'Kompilering' er prosessen med √• oversette kildekode til objektkode."
mc,"Lecture 6","Hvilken av f√∏lgende er en potensiell ulempe med statisk linking?",,"√òkt avhengighet av eksterne biblioteker ved kj√∏retid.|St√∏rre kj√∏rbare filer som kan f√∏re til sl√∏sing av diskplass.|Tiden det tar √• starte programmet √∏ker.|Vanskeligere √• oppdatere biblioteker.",1,"En ulempe med statisk linking er at den kj√∏rbare filen blir st√∏rre, og at diskplass sl√∏ses hvis mange programmer bruker det samme biblioteket.\n\nAlternativ '√òkt avhengighet av eksterne biblioteker ved kj√∏retid' er en ulempe med dynamisk linking. \nAlternativ 'Tiden det tar √• starte programmet √∏ker' er mer relatert til lasting av mange dynamiske biblioteker eller oppstart av nye prosesser.\nAlternativ 'Vanskeligere √• oppdatere biblioteker' er ogs√• en ulempe med statisk linking fordi man m√• rekompilere og redistribuere alle applikasjoner som bruker biblioteket n√•r det oppdateres."
mc,"Lecture 6","Hvilken standardstr√∏m brukes vanligvis for √• sende feilmeldinger fra et program?",,"stdin|stdout|stderr|stdlog",2,"stderr (standard error) er standardstr√∏mmen som brukes for feilmeldinger fra programmet.\n\nAlternativ 'stdin (standard input)' brukes for inndata til programmet.\nAlternativ 'stdout (standard output)' brukes for normal utdata fra programmet.\nAlternativ 'stdlog' er ikke en av de tre standardstr√∏mmene som operativsystemet gir til en prosess ved oppstart."
mc,"Lecture 6","Hva indikerer vanligvis en statuskode (exit code) forskjellig fra 0 n√•r et program avsluttes?",,"Programmet har fullf√∏rt uten problemer.|Programmet ble tvangsavsluttet av brukeren.|Det har oppst√•tt en feil under utf√∏relsen av programmet.|Programmet venter fortsatt p√• inndata.",2,"En statuskode forskjellig fra 0 indikerer konvensjonelt at det har oppst√•tt en feil under utf√∏relsen av programmet. En statuskode p√• 0 indikerer at programmet ble utf√∏rt uten feil.\n\nAlternativ 'Programmet har fullf√∏rt uten problemer' tilsvarer en statuskode p√• 0.\nAlternativ 'Programmet ble tvangsavsluttet av brukeren' kan resultere i en statuskode forskjellig fra 0, men det er mer spesifikt en √•rsak til feil eller avbrudd.\nAlternativ 'Programmet venter fortsatt p√• inndata' betyr at programmet ikke har avsluttet enn√• og vil derfor ikke ha returnert en statuskode."
mc,"Lecture 6","Hvilken funksjonalitet i C++ brukes for √• sikre at C++-funksjoner kan kalles direkte fra C-kode?",,"Navnemangling|Klasser|Templating|extern ""C""",3,"`extern ""C""` brukes i C++ for √• hindre navnemangling. Dette er n√∏dvendig for at funksjonsnavnene skal v√¶re kompatible med C-koblingskonvensjoner, slik at C-kode kan finne og kalle C++-funksjoner. \n\nAlternativ 'Navnemangling' er prosessen som extern ""C"" fors√∏ker √• unng√• i dette tilfellet.\nAlternativ 'Klasser' og 'Templating' er andre viktige konsepter i C++, men de er ikke direkte relatert til kompatibilitet med C-kobling p√• denne m√•ten."
mc,"Lecture 6","Hvilken av f√∏lgende er en potensiell ulempe ved √• starte en ny prosess for √• utf√∏re kode i et annet spr√•k?",,"Bedre minneh√•ndtering.|√òkt sikkerhet p√• grunn av prosessisolering.|Tidsforsinkelse p√• grunn av oppstart og administrasjon av den nye prosessen.|Enklere deling av ressurser.",2,"En potensiell ulempe ved √• starte en ny prosess er at det tar tid √• starte en ny prosess p√• grunn av at den kj√∏rbare filen m√• lastes inn i minnet og operativsystemet m√• utf√∏re administrasjon. Dette kan f√∏re til tidsforsinkelse, spesielt ved hyppig kj√∏ring av sm√• kodebiter. \n\nAlternativ 'Bedre minneh√•ndtering' kan v√¶re en fordel i visse tilfeller p√• grunn av prosessisolering, men er ikke en generell ulempe ved oppstart.\nAlternativ '√òkt sikkerhet p√• grunn av prosessisolering' er en fordel, ikke en ulempe.\nAlternativ 'Enklere deling av ressurser' er ikke n√∏dvendigvis en direkte konsekvens eller fordel ved √• starte en ny prosess for kode i et annet spr√•k; deling av ressurser mellom prosesser krever spesifikke mekanismer."
qa,"Lecture 7","Hva betyr det for et program √• √•pne en fil, og hvorfor er det viktig √• lukke filh√•ndtaket n√•r man er ferdig?","√Ö √•pne en fil betyr at programmet ber operativsystemet om √• finne filen og opprette en ""forbindelse"" (filh√•ndtak/fildeskriptor). Det er viktig √• lukke filh√•ndtaket n√•r man er ferdig for √• frigj√∏re systemressurser og unng√• ressurslekkasjer, da det er en grense for hvor mange filh√•ndtak et program kan ha √•pent samtidig.",,,
qa,"Lecture 7","Nevn de tre standardstr√∏mmene som ethvert prosess mottar fra operativsystemet ved oppstart, og beskriv kort hva hver av dem brukes til.","De tre standardstr√∏mmene er stdin (standard input) for inndata fra brukeren eller en annen prosess, stdout (standard output) for vanlige utdata til brukeren eller en annen prosess, og stderr (standard error) for feilmeldinger.",,,
qa,"Lecture 7","Hva er hovedforskjellen mellom sekvensiell og tilfeldig (random) filtilgang, og hvilken type er generelt raskere for diskoperasjoner?","Sekvensiell filtilgang betyr √• lese eller skrive data i rekkef√∏lge, fra begynnelsen til slutten, mens tilfeldig filtilgang betyr √• f√• tilgang til data i en vilk√•rlig rekkef√∏lge ved √• bruke ""seek""-operasjoner. Sekvensiell tilgang er generelt raskere fordi disken kan lese sammenhengende blokker mer effektivt.",,,
qa,"Lecture 7","Forklar kort hva en diskcache er og hvorfor man m√• kalle sync() i visse situasjoner.","En diskcache er en mekanisme i operativsystemet som lagrer nylig leste eller skrivne diskblokker i minnet. Dette gj√∏r at fremtidige tilganger til de samme dataene kan skje raskere fra minnet i stedet for den tregere disken. Man m√• kalle sync() for √• v√¶re absolutt sikker p√• at data som er skrevet har blitt fysisk lagret p√• disken, da data f√∏rst kan ligge i diskcachen.",,,
qa,"Lecture 7","Hva er Unicode, og hva er hensikten med det? Nevn minst to vanlige UTF-enkodinger.","Unicode er et omfattende tegnesett som har som m√•l √• definere et unikt kodeunkt for de fleste tegn i alle skriftlige menneskelige spr√•k. To vanlige UTF-enkodinger inkluderer UTF-8 (variabel lengde, 1-4 bytes per tegn) og UTF-16 (vanligvis 2 eller 4 bytes per tegn).",,,
qa,"Lecture 7","Forklar kort hvordan en with-setning i Python bidrar til √• unng√• lekkasjer av filh√•ndtak.","En with-setning i Python sikrer at en ressurs (som en fil) blir korrekt h√•ndtert, spesielt med tanke p√• lukking. Objektet som brukes med with er en ""context manager"" som har metoder for √• tre i kraft ved inngangen (__enter__) og utgangen (__exit__) av blokken. Selv om det oppst√•r en feil inne i with-blokken, vil __exit__-metoden (som for filer inkluderer lukking) alltid bli kj√∏rt.",,,
mc,"Lecture 7","Hva er den prim√¶re funksjonen til et filh√•ndtak(fildeskriptor)? Svaralternativer:",,"√Ö lagre innholdet i en fil permanent p√• disken.|√Ö gi et program en abstrakt m√•te √• identifisere og samhandle med en √•pen fil administrert av operativsystemet.|√Ö kryptere innholdet i en fil for sikker lagring.|√Ö komprimere filst√∏rrelsen for √• spare diskplass.",1,"Et filh√•ndtak (ogs√• kalt fildeskriptor) er en abstrakt indikator som operativsystemet bruker for √• identifisere en √•pen fil. Det er denne indikatoren programmet bruker for √• utf√∏re operasjoner som lesing og skriving.\n\nAlternativet om permanent lagring beskriver filsystemets generelle funksjon. Kryptering og komprimering er separate prosesser som ikke er direkte knyttet til filh√•ndtakets prim√¶re funksjon."
mc,"Lecture 7","Hvorfor strukturerer databaser data i indekser ved hjelp av trestrukturer eller hash-tabeller?",,"For √• redusere det totale datavolumet som m√• lagres p√• disken.|For √• sikre at dataene lagres i kronologisk rekkef√∏lge basert p√• innsettingstidspunktet.|For √• raskt kunne lokalisere spesifikke data p√• disken ved √• minimere antall diskoperasjoner.|For √• optimalisere sekvensiell lesing av data i store tabeller.",2,"Indekser basert p√• trestrukturer (som B-tr√¶r) eller hash-tabeller brukes av databaser for √• raskt finne spesifikke data. Disse strukturene er optimalisert for diskoperasjoner ved √• organisere data slik at f√¶rrest mulig diskaksesser er n√∏dvendig for √• finne den √∏nskede informasjonen. Datakomprimering er ikke indeksenes prim√¶re form√•l, rekkef√∏lgen av data i indeksen er logisk basert p√• n√∏kkelverdier, og indekser er prim√¶rt for raske oppslag, ikke optimalisering av sekvensiell lesing."
mc,"Lecture 7","Hva er hovedideen bak ekstern sortering n√•r man har data som ikke f√•r plass i minnet?",,"√Ö bruke mer av prosessorens cache for √• h√•ndtere de store datamengdene.|√Ö dele dataene opp i mindre biter som kan sorteres individuelt i minnet og deretter sl√•s sammen ved hjelp av disk I/O.|√Ö dynamisk √∏ke st√∏rrelsen p√• hovedminnet ved bruk av diskplass som virtuelt minne.|√Ö komprimere dataene f√∏r sortering for √• redusere minnebruken under sorteringsprosessen.",1,"Ekstern sortering brukes n√•r data er for stort til √• passe i minnet. Ideen er √• dele dataene opp i h√•ndterbare biter, sortere hver bit i minnet, og deretter sl√• sammen de sorterte bitene til en endelig sortert fil ved hjelp av disk I/O.\n\nSelv om √∏kt bruk av cache kan hjelpe, er ikke det hovedideen.\nVirtuelt minne h√•ndteres av operativsystemet og l√∏ser ikke n√∏dvendigvis problemet med store datasett i minnet for en sorteringsalgoritme.\nKomprimering kan redusere st√∏rrelsen, men l√∏ser sjelden problemet med at dataene er fundamentalt for store for minnet under sortering."
mc,"Lecture 7","Hva er den grunnleggende forskjellen mellom en streng og en byte-array i databehandling?",,"En streng kan bare inneholde numeriske verdier, mens en byte-array kan inneholde tekstdata.|En streng er en sekvens av tegn, mens en byte-array er en sekvens av numeriske byte-verdier.|En streng er lagret direkte p√• disken som en fil, mens en byte-array er kun i minnet.|Det er ingen fundamental forskjell; begrepene brukes synonymt i de fleste programmeringsspr√•k.",1,"En streng representerer tekst som en sekvens av tegn, der hvert tegn har en abstrakt representasjon (kodeunkt). En byte-array derimot, er en lavniv√•representasjon av bin√¶re data, hvor hvert element er en numerisk byte-verdi. Konvertering mellom de to krever bruk av en tegnekoding."
mc,"Lecture 7","Hvorfor er tegnesett og tegnekoding n√∏dvendig n√•r man arbeider med tekst i datamaskiner?",,"For √• sikre at tekstdata tar mindre plass ved lagring og overf√∏ring.|For √• kunne konvertere mellom menneskelig lesbar tekst (tegn) og maskinens bin√¶re representasjon (bytes).|For √• kryptere tekstdata slik at de ikke kan leses av uvedkommende.|For √• optimalisere hastigheten p√• teksts√∏k i store dokumenter.",1,"Et tegnesett definerer hvilke tegn som finnes og gir hvert tegn en unik kode (kodeunkt). En tegnekoding definerer hvordan disse kodeunktene representeres som en sekvens av bits (bytes) for lagring og overf√∏ring. Uten dette systemet ville datamaskiner ikke kunne tolke og vise tekst korrekt.\nKomprimering og kryptering er separate prosesser, og selv om tegnesett og koding indirekte kan p√•virke s√∏kehastighet ved √• bestemme datastrukturen, er ikke det deres prim√¶re n√∏dvendighet."
mc,"Lecture 7","Hvilken viktig fordel gir bruken av en with-setning (eller tilsvarende konstruksjoner) ved h√•ndtering av filer sammenlignet med manuell √•pning og lukking?",,"Den gj√∏r filoperasjoner raskere ved √• optimalisere disk I/O.|Den sikrer at filen lukkes automatisk, selv om det oppst√•r feil (unntak) i kodeblokken.|Den gir bedre kontroll over filens tilgangsrettigheter.|Den reduserer minnebruken ved h√•ndtering av store filer.",1,"En with-setning (og lignende konstruksjoner som try-with-resources i Java og smarte pekere i C++) er utformet for √• automatisere ressursh√•ndtering, spesielt lukking av filer. Selv om det oppst√•r en feil inne i blokken, vil ressursen bli korrekt frigjort. Dette bidrar til √• unng√• ressurslekkasjer.\nSelv om korrekt lukking er viktig for ytelsen og kan indirekte p√•virke minnebruk, er den prim√¶re fordelen den garanterte lukkingen ogs√• ved feil. Kontroll over tilgangsrettigheter h√•ndteres p√• et annet niv√•."
qa,"Lecture 8","Hva er hovedforskjellen mellom tekstuelle og bin√¶re filformater? Gi ett eksempel p√• hver","Hovedforskjellen er at tekstuelle filformater er lesbare for mennesker i en teksteditor, mens bin√¶re formater ikke er direkte menneskelesbare. Et eksempel p√• et tekstuelt format er HTML. Et eksempel p√• et bin√¶rt format er JPEG.",,,
qa,"Lecture 8","Hvilken funksjon har filnavnendelsen?","Filnavnendelsen er kun en indikasjon til brukeren og operativsystemet om filtypen og p√•virker ikke hvordan dataen er strukturert i filen. Endelsen hjelper operativsystemet med √• bestemme hvilket program som skal √•pne filen.",,,
qa,"Lecture 8","Nevn tre viktige kjennetegn ved CSV-formatet. Hvordan h√•ndterer CSV verdier som inneholder komma eller anf√∏rselstegn?","Tre viktige kjennetegn ved CSV-formatet er at det er et tekstuelt format for tabul√¶r data der verdier er separert med komma og rader med linjeskift. Det finnes ingen standard m√•te √• indikere filens karakterkoding. Verdier som inneholder komma eller anf√∏rselstegn m√• omsluttes av anf√∏rselstegn, og eventuelle anf√∏rselstegn inni verdien m√• dobles.",,,
qa,"Lecture 8","Beskriv forskjellen mellom lossy og lossless komprimering. Gi ett eksempel p√• et filformat som bruker lossy komprimering, og ett som bruker lossless komprimering.","Lossy komprimering fjerner noe data for √• oppn√• h√∏yere komprimeringsrate, noe som kan resultere i tap av kvalitet. Lossless komprimering reduserer filst√∏rrelsen uten √• miste noen informasjon, slik at originaldataene kan gjenopprettes n√∏yaktig. Et eksempel p√• et filformat som bruker lossy komprimering er MP3. Et eksempel p√• et som bruker lossless komprimering er PNG.",,,
qa,"Lecture 8","Hva betyr serialisering og deserialisering i sammenheng med programmeringsspr√•k? Nevn en ulempe eller fare ved bruk av innebygd serialisering.","Serialisering er prosessen med √• konvertere et objekt i minnet til et format som kan lagres (f.eks. i en fil) eller overf√∏res over et nettverk. Deserialisering er prosessen med √• gjenopprette objektet fra dette lagrede formatet. En fare ved innebygd serialisering (som Pickle i Python) er sikkerhetsrisikoen, da deserialiserte data potensielt kan inneholde skadelig kode.",,,
qa,"Lecture 8","Forklar det generelle prinsippet bak komprimering. Hvorfor har det ingen effekt √• komprimere en fil gjentatte ganger med samme algoritme?","Komprimering fungerer ved √• utnytte m√∏nstre og redundans i dataen for √• representere den mer effektivt. Gjentatt komprimering med samme algoritme har ingen effekt fordi algoritmen allerede har utnyttet alle de gjenkjennelige m√∏nstrene i den f√∏rste komprimeringsrunden, og det er ingen ytterligere redundans igjen for algoritmen √• utnytte.",,,
mc,"Lecture 8","Hva er den obligatoriske karakterkodingen som alltid benyttes for JSON-dokumenter?",,"ASCII |UTF-16|UTF-8 |ISO-8859-1",2,"JSON-dokumenter m√• alltid v√¶re kodet i UTF-8. \n\nAlternativ 'ASCII' er en eldre karakterkoding som ikke st√∏tter alle internasjonale tegn. \nAlternativ 'UTF-16' er en annen Unicode-transformasjonsformat, men ikke det obligatoriske for JSON. \nAlternativ 'ISO-8859-1' er en annen karakterkoding som er begrenset til vest-europeiske tegn."
mc,"Lecture 8","Hvilken type komprimering reduserer filst√∏rrelsen ved √• fjerne noe informasjon, noe som potensielt kan medf√∏re tap av kvalitet?",,"Lossless komprimering |Run-length encoding|Lossy komprimering|Huffman-koding",2,"Komprimeringstypen som fjerner data for √• redusere filst√∏rrelsen og kan f√∏re til kvalitetstap er lossy komprimering.\n\nAlternativ 'Lossless komprimering' reduserer filst√∏rrelsen uten √• miste informasjon. \nAlternativ 'Run-length encoding' er en form for lossless komprimering som erstatter gjentatte sekvenser. \nAlternativ 'Huffman-koding' er en lossless komprimeringsalgoritme basert p√• frekvensen av symboler."
mc,"Lecture 8","Hva er den prim√¶re hensikten med funksjonene `struct.pack` og `struct.unpack` i Python?",,"√Ö konvertere tekst til bin√¶r kode og tilbake.|√Ö komprimere og dekomprimere data.|√Ö konvertere data mellom in-memory representasjon og en byte-sekvens.|√Ö serialisere og deserialisere Python-objekter til fil.",2,"`struct.pack` og `struct.unpack` i Python brukes prim√¶rt for √• konvertere data mellom deres representasjon i minnet og en sekvens av bytes. \n\nAlternativ '√Ö konvertere tekst til bin√¶r kode og tilbake' beskriver funksjonaliteten til encode() og decode(). \nAlternativ '√Ö komprimere og dekomprimere data' beskriver form√•let med komprimeringsalgoritmer som DEFLATE eller gzip. \nAlternativ '√Ö serialisere og deserialisere Python-objekter til fil' beskriver funksjonaliteten til serialiseringsbiblioteker som pickle eller json."
mc,"Lecture 8","Hvilken p√•stand beskriver hovedideen bak Lempel-Ziv-komprimering (LZ77)?",,"√Ö erstatte hyppige symboler med kortere koder basert p√• deres frekvens|√Ö fjerne redundant informasjon som ikke er synlig for det menneskelige √∏yet.|√Ö se etter gjentakelser av tegnsekvenser og erstatte p√•f√∏lgende forekomster med referanser.|√Ö gruppere like elementer i lange sekvenser og representere dem med en telling og elementet.",2,"Hovedideen bak Lempel-Ziv-komprimering er √• identifisere gjentakende tegnsekvenser og erstatte senere forekomster med en referanse til den f√∏rste forekomsten.\n\nAlternativ '√Ö erstatte hyppige symboler med kortere koder' beskriver prinsippet bak Huffman-koding.\nAlternativ '√Ö fjerne redundant informasjon som ikke er synlig for det menneskelige √∏yet' beskriver en egenskap ved lossy komprimering.\nAlternativ '√Ö gruppere like elementer i lange sekvenser og representere dem med en telling og elementet' beskriver run-length encoding."
mc,"Lecture 8","I hvilken situasjon er det mest hensiktsmessig √• bruke en databasemotor i stedet for √• lagre data i filformater som CSV eller JSON?",,"N√•r dataene prim√¶rt best√•r av enkle lister med verdier som sjelden endres.|N√•r man har behov for hyppige s√∏k etter spesifikke dataelementer i en stor datasamling.|N√•r m√•let er √• enkelt kunne lese og redigere dataen direkte i en teksteditor.|N√•r man √∏nsker √• minimere avhengigheten av ekstern programvare for √• f√• tilgang til dataen.",1,"Det er mest hensiktsmessig √• bruke en databasemotor n√•r man har behov for hyppige s√∏k etter spesifikke dataelementer i en stor datasamling p√• grunn av dens evne til √• indeksere og h√•ndtere data effektivt. \n\nAlternativ 'N√•r dataene prim√¶rt' kan ofte h√•ndteres tilstrekkelig med enkle filformater. \nAlternativ 'N√•r m√•let er √•' taler for bruk av tekstuelle filformater.\nAlternativ 'N√•r man √∏nsker' kan ogs√• favorisere enklere filformater, selv om databaser krever spesifikk programvare for tilgang og administrasjon."
qa,"Lecture 9","Hva er hovedproblemet som generics og C++ templates fors√∏ker √• l√∏se i statisk typede spr√•k?","Hovedproblemet er kode-duplisering og manglende type-sikkerhet n√•r man √∏nsker √• skrive algoritmer som kan operere p√• flere forskjellige datatyper. Generics og templates tillater √• skrive √©n enkelt versjon av koden som kan tilpasses ulike typer.",,,
qa,"Lecture 9","Hvorfor m√• malfunksjoner som brukes i flere .cpp-filer defineres i en headerfil (.h) i C++?","Malfunksjoner m√• defineres i headerfilen fordi template-koden m√• v√¶re tilgjengelig for compileren hver gang den instansieres med en ny type i en annen kompileringsenhet. Headerfiler inneholder deklarasjoner, mens kildekodefiler inneholder definisjoner.",,,
qa,"Lecture 9","Hva skjer n√•r en malfunksjon instansieres med en spesifikk type i C++, og hvordan skiller dette seg fra generics i Java?","N√•r en malfunksjon instansieres, genererer compileren en ny, spesifikk versjon av funksjonen for den gitte typen. I motsetning til Java, hvor det ofte er √©n kompilert klasse som h√•ndterer ulike typer (type erasure), er de kompilerte versjonene i C++ uavhengige av hverandre.",,,
qa,"Lecture 9","Hva betyr det √• spesialisere en malbasert klasse for en spesifikk type?","√Ö spesialisere en malbasert klasse betyr √• lage en s√¶rskilt implementasjon av en template for en bestemt type. Et eksempel er spesialiseringen av vector<bool> for √• optimalisere minnebruk ved √• lagre flere boolske verdier per integer.",,,
qa,"Lecture 9","Hva er hensikten med include guards i en headerfil i C++ og hvorfor er de viktige?","Hensikten med include guards er √• forhindre at innholdet i en headerfil blir inkludert flere ganger i samme kompileringsenhet. Uten include guards kan dette f√∏re til redefinisjonsfeil under kompileringen.",,,
qa,"Lecture 9","Hva er STL i C++ og gi eksempler p√• to template-klasser som er en del av STL.","STL (Standard Template Library) er en omfattende del av C++ standardbibliotek som inneholder mange generiske datastrukturer og algoritmer. Eksempler inkluderer vector (en dynamisk array) og priority_queue (en prioritetsk√∏).",,,
mc,"Lecture 9","Hva er en C++ template?",,"En spesifikk implementasjon av en funksjon eller klasse for en gitt datatype.|En mekanisme for √• definere funksjoner og klasser som kan operere p√• forskjellige typer. |En kompileringsfeil som oppst√•r n√•r man bruker generisk kode feil.|En del av standardbiblioteket som kun inneholder datastrukturer.",1,"En C++ template er en mekanisme for √• definere funksjoner og klasser som kan operere p√• forskjellige typer. Dette er selve definisjonen av en template, som er C++ sin implementasjon av generics.\n\nAlternativ 'En spesifikk implementasjon' beskriver resultatet av en template instansiering, ikke selve template.\nAlternativ 'En kompileringsfeil' er feil; templates er en gyldig spr√•kkonstruksjon.\nAlternativ 'En del av standardbiblioteket' er delvis riktig (STL inneholder datastrukturer), men templates er en spr√•kfunksjon i seg selv, og STL inneholder ogs√• algoritmer."
mc,"Lecture 9","Hva kjennetegner template instansiering i C++?",,"Koden for templaten blir kompilert √©n gang uavhengig av typene som brukes.|Compileren genererer spesifikk kode for hver type templaten brukes med.|Det skjer en typekonvertering til en felles supertype under kj√∏retid.|Templaten blir ignorert av compileren hvis den ikke brukes med konkrete typer.",1,"Under template instansiering i C++, genererer compileren spesifikk kode for hver type templaten brukes med. Dette betyr at for hver unik datatype som brukes med en template, skapes en separat versjon av koden.\n\nAlternativ 'Koden for templaten blir kompilert √©n gang' er mer likt hvordan generics fungerer i spr√•k med type erasure, som Java.\nAlternativ 'Det skjer en typekonvertering' er ikke relevant for C++ templates; typene er bestemt ved kompilering.\nAlternativ 'Templaten blir ignorert' er feil; templaten m√• instansieres for √• generere kj√∏rbar kode for de spesifikke typene."
mc,"Lecture 9","Hva er hovedform√•let med template spesialisering?",,"√Ö gj√∏re template-koden mer generell og anvendelig for flere datatyper.|√Ö tilby en optimalisert eller annerledes implementasjon for en eller flere spesifikke datatyper.|√Ö tvinge compileren til √• bruke en bestemt datatype med en template.|√Ö forhindre at en template kan brukes med visse datatyper.",1,"Hovedform√•let med template spesialisering er √• tilby en optimalisert eller annerledes implementasjon av en template for en eller flere spesifikke datatyper. Dette tillater skreddersydd oppf√∏rsel for tilfeller der den generelle implementasjonen ikke er ideell.\n\nAlternativ '√Ö gj√∏re template-koden mer generell' er det motsatte av spesialisering.\nAlternativ '√Ö tvinge compileren til √• bruke en bestemt datatype' er ikke form√•let; spesialisering trer i kraft n√•r en bestemt datatype brukes.\nAlternativ '√Ö forhindre at en template kan brukes' er heller ikke form√•let; spesialisering gir en alternativ bruk."
mc,"Lecture 9","Hvilken p√•stand er korrekt ang√•ende bitwise operatorer i henhold til kilden?",,"De opererer p√• hele datatyper som int eller float som en helhet.|De manipulerer de enkelte bitene i heltallsdatatyper. |De brukes hovedsakelig for sammenligning av numeriske verdier.|De er ikke relevante i sammenheng med C++ templates.",1,"Bitwise operatorer manipulerer de enkelte bitene i heltallsdatatyper. Kilden nevner AND (&), OR (|) og NOT (~) som eksempler p√• hvordan de opererer p√• bitniv√•.\n\nAlternativ 'De opererer p√• hele datatyper' er feil; de opererer p√• bitene.\nAlternativ 'De brukes hovedsakelig for sammenligning' er feil; sammenligningsoperatorer har et annet form√•l.\nAlternativ 'De er ikke relevante i sammenheng med C++ templates' er feil; selv om ikke direkte knyttet, kan templates brukes med typer som bitwise operatorer kan operere p√•."
mc,"Lecture 9","Hva er en potensiell ulempe ved bruk av template metaprogrammering?",,"Det kan f√∏re til lengre kompileringstider. |Det resulterer alltid i mindre kj√∏rbare filer.|Det gj√∏r koden mer lettlest og forst√•elig.|Det begrenser mulighetene for gjenbruk av kode.",0,"En potensiell ulempe ved bruk av template metaprogrammering er at dette kan f√∏re til lengre kompileringstider. Beregninger utf√∏res under kompilering, noe som kan √∏ke tiden det tar √• bygge programmet.\n\nAlternativ 'Det resulterer alltid i mindre kj√∏rbare filer' er ikke garantert; selv om beregninger flyttes til kompileringstid, kan kompleks template-kode ogs√• √∏ke st√∏rrelsen.\nAlternativ 'Det gj√∏r koden mer lettlest' er ofte ikke tilfelle; template metaprogrammering kan v√¶re abstrakt og vanskelig √• forst√•.\nAlternativ 'Det begrenser mulighetene for gjenbruk av kode' er feil; templates generelt fremmer gjenbruk."
mc,"Lecture 9","Hva er en forutsetning for √• kunne bruke `std::sort-funksjonen` fra STL med en brukerdefinert klasse?",,"Klassen m√• arve fra en bestemt baseklasse i STL.|lassen m√• ha en medlemsfunksjon kalt sort().|<-operatoren m√• v√¶re definert for den klassen.|Klassen m√• kun inneholde primitive datatyper som medlemmer.",2,"For √• bruke std::sort med en brukerdefinert klasse, m√• <-operatoren v√¶re definert for den klassen. std::sort bruker denne operatoren for √• sammenligne elementer og bestemme rekkef√∏lgen under sorteringen.\n\nAlternativ 'Klassen m√• arve fra en bestemt baseklasse' er ikke et krav for std::sort.\nAlternativ 'Klassen m√• ha en medlemsfunksjon kalt sort()' er feil; std::sort er en frittst√•ende funksjon.\nAlternativ 'Klassen m√• kun inneholde primitive datatyper' er ikke riktig; std::sort kan sortere objekter av komplekse klasser s√• lenge sammenligningsoperatoren er definert."
qa,"Lecture 10","Hvordan h√•ndterer Java generiske typer under kj√∏ring i motsetning til C++ templates?","I Java er det kun √©n kompilert versjon av en generisk klasse, og typeinformasjonen g√•r tapt under kj√∏ring p√• grunn av ""runtime type erasure"". I C++ genereres en ny versjon av klassen eller funksjonen for hver spesifikk type den brukes med.",,,
qa,"Lecture 10","Hvilke to hovedfordeler gir bruken av generics i Java sammenlignet med √• bruke Object for parametere og returverdier?","Fordelene inkluderer unng√•else av eksplisitt typekonvertering (casting) og sikring av at alle parametere og returverdier har samme spesifikke type, i stedet for bare √• v√¶re av en felles supertype.",,,
qa,"Lecture 10","Nevn tre operasjoner som kan utf√∏res p√• en variabel av en ubegrenset generisk typeparameter T i Java.","Tillatte operasjoner inkluderer √• kalle metoder definert i Object-klassen (toString(), equals(), hashCode()), sende den som et argument til en annen funksjon, og deklarere variabler av den typen.",,,
qa,"Lecture 10","Hvorfor tillater ikke Java automatisk konvertering fra `List<Apple>` til `List<Fruit>` selv om Apple er en subklasse av Fruit?","Dette er for √• forhindre potensielle typefeil som kunne oppst√• hvis man kunne legge til et Orange-objekt i en liste som egentlig er ment for Apple-objekter, noe som ville f√∏rt til en ClassCastException senere.",,,
qa,"Lecture 10","Hva er et funksjonelt grensesnitt i Java, og hvor mange abstrakte metoder kan det inneholde?","En funksjonell grensesnitt i Java er et grensesnitt som har n√∏yaktig √©n abstrakt metode (metode uten standardimplementasjon). Det kan ha flere metoder med standardimplementasjon.",,,
qa,"Lecture 10","Beskriv kort funksjonaliteten til `filter()`, `map()`, og `toList()` operasjonene i Java Stream API.","`filter()` velger ut elementer basert p√• et predikat.\n`map()` transformerer hvert element ved hjelp av en funksjon, og \n`toList()` samler elementene i en str√∏m til en ny List.",,,
mc,"Lecture 10","Hvilket begrep beskriver fenomenet der informasjon om generiske typeparametere ikke eksisterer under kj√∏ring i Java?",,"Type inferens|Runtime polymorphism.|Runtime type erasure.|Boxing og unboxing.",2,"Fenomenet der informasjon om generiske typeparametere g√•r tapt under kj√∏ring kalles runtime type erasure. Dette betyr at ved kj√∏retid er ikke den spesifikke typen i en generisk klasse eller metode tilgjengelig.\n\nAlternativ 'Type inferens' refererer til kompilatorens evne til √• utlede typen av et generisk argument.\nAlternativ 'Runtime polymorphism' er mekanismen som gj√∏r at et objekt kan ta mange former ved kj√∏retid basert p√• dets faktiske type.\nAlternativ 'Boxing og unboxing' er prosessen med √• konvertere mellom primitive typer og deres wrapper-objekter."
mc,"Lecture 10","Hvilken syntaks i Java generics tillater at man kan behandle en generisk type med en subklasse som en generisk type med en superklasse, med restriksjoner p√• hva man kan gj√∏re med samlingen (kun hente elementer)?",,"<T>|<? super T>|<? extends T>|<T extends Comparable>",2,"Syntaksen <? extends T> representerer kovarians i Java generics. Dette tillater at en samling av en subtype kan behandles som en samling av supertypen T, men man kan generelt bare hente elementer fra den (den er en ""produsent"").\n\nAlternativ <T> representerer en ubegrenset generisk typeparameter.\nAlternativ <? super T> representerer kontravarians, hvor en samling av en supertype kan behandles som en samling av subtypen T, og man kan generelt bare legge til elementer i den (den er en ""konsument"").\nAlternativ <T extends Comparable> representerer en begrenset generisk typeparameter, hvor T m√• v√¶re en subklasse av Comparable."
mc,"Lecture 10","Hvor mange abstrakte metoder kan et funksjonelt grensesnitt i Java ha?",,"Null eller flere.|Minst √©n|N√∏yaktig √©n.|Mer enn √©n.",2,"Et funksjonelt grensesnitt i Java er definert som et grensesnitt som inneholder n√∏yaktig √©n abstrakt metode (en metode uten standardimplementasjon).\n\nAlternativ 'Null eller flere' er for generelle grensesnitt.\nAlternativ 'Minst √©n' gjelder for mange grensesnitt, men funksjonelle grensesnitt er spesifikke.\nAlternativ 'Mer enn √©n' er ikke tillatt for funksjonelle grensesnitt."
mc,"Lecture 10","Hvilken av f√∏lgende beskriver best hensikten med Java Stream API?",,"√Ö definere anonyme funksjoner. |√Ö forenkle bearbeiding av samlinger av data p√• en deklarativ m√•te.|√Ö h√•ndtere unntak under kj√∏ring.|√Ö definere klasser som kan operere p√• en hvilken som helst type.",1,"Java Stream API er designet for √• forenkle bearbeiding av samlinger av data p√• en deklarativ m√•te. Det tilbyr metoder for √• utf√∏re operasjoner som filtrering, mapping og reduksjon p√• sekvenser av elementer.\n\nAlternativ '√Ö definere anonyme funksjoner' beskriver bruken av lambda-funksjoner. \nAlternativ '√Ö h√•ndtere unntak under kj√∏ring' er ansvaret til try-catch-blokker og unntaksh√•ndteringsmekanismer.\nAlternativ '√Ö definere klasser som kan operere p√• en hvilken som helst type' beskriver form√•let med generics."
mc,"Lecture 10","Hvilken av de f√∏lgende operasjonene er et eksempel p√• en stream-operasjon som transformerer hvert element i str√∏mmen til et annet element?",,"filter()|reduce()|map()|forEach()",2,"Operasjonen map() i Java Stream API transformerer hvert element i str√∏mmen til et annet element ved hjelp av en gitt funksjon.\n\nAlternativ filter() velger ut elementer basert p√• et predikat. \nAlternativ reduce() kombinerer elementene i str√∏mmen til √©n enkelt verdi.\nAlternativ forEach() utf√∏rer en handling for hvert element i str√∏mmen, men transformerer ikke elementene i seg selv."
mc,"Lecture 10","Hvilket av f√∏lgende er en korrekt syntaks for en enkel lambda-funksjon i Java som tar en parameter y og returnerer verdien av y addert med 5?",,"(y) -> return y + 5;|y -> { y + 5 }|y => y + 5|y -> y + 5",3,"Den korrekte syntaksen for en lambda-funksjon som tar en parameter y og returnerer y + 5 er `y -> y + 5`. Hvis lambda-kroppen best√•r av et enkelt uttrykk, kan man utelate kr√∏llparentesene og return-n√∏kkelordet.\n\nAlternativ (y) -> return y + 5; er nesten korrekt, men return er un√∏dvendig for et enkelt uttrykk uten kr√∏llparenteser.\nAlternativ y -> { y + 5 } utf√∏rer beregningen, men returnerer ikke n√∏dvendigvis verdien uten et eksplisitt return inne i kr√∏llparentesene i dette tilfellet.\nAlternativ y => y + 5 bruker feil syntaks (=> brukes i JavaScript, ikke Java)."
qa,"Lecture 11","Hva er hovedideen bak et designm√∏nster?","Hovedideen bak et designm√∏nster er √• tilby en gjenbrukbar l√∏sning p√• et vanlig forekommende problem i programvaredesign. Det er en mal eller veiledning for √• strukturere kode for √• oppn√• egenskaper som fleksibilitet og vedlikeholdbarhet. I motsetning til algoritmer og datastrukturer, som er spesifikke steg eller organisering av data, er et designm√∏nster en mer overordnet id√© som kan gjenbrukes og tilpasses ulike situasjoner for √• h√•ndtere arkitektoniske utfordringer.",,,
qa,"Lecture 11","Hva er et Java-grensesnitt(interface)?","Et Java-grensesnitt definerer et sett med funksjonssignaturer uten implementasjon. N√•r en klasse implementerer et grensesnitt, inng√•r klassen en ""kontrakt"" om √• tilby implementasjon for alle metodene som er definert i grensesnittet. Et grensesnitt er en spesifikasjon av et sett med metoder som en klasse kan implementere.",,,
qa,"Lecture 11","Beskriv kort hva Adapter-m√∏nsteret gj√∏r.","Adapter-m√∏nsteret er et strukturm√∏nster som tillater at klasser med inkompatible grensesnitt kan samarbeide. Det l√∏ser problemet med √• bruke en eksisterende klasse som ikke implementerer et n√∏dvendig grensesnitt. Adapteren fungerer som en bro ved √• konvertere grensesnittet til en klasse til et annet grensesnitt som klienten forventer. Dette oppn√•s ved √• lage en adapterklasse som omslutter en instans av den eksisterende klassen og implementerer det p√•krevde grensesnittet ved √• delegere kall til den underliggende klassen.",,,
qa,"Lecture 11","Hva er hensikten med Decorator-m√∏nsteret?","Hensikten med Decorator-m√∏nsteret er √• legge til ekstra funksjonalitet (som logging eller tidsm√•ling) til metoder i en eksisterende klasse uten √• endre selve klassen. Dette er et strukturm√∏nster som dynamisk legger til ansvar til et objekt. Dette oppn√•s ved √• lage en dekoratorklasse som omslutter en instans av den opprinnelige klassen og delegerer metodekall til den, samtidig som den utf√∏rer den ekstra handlingen f√∏r og/eller etter delegeringen. Dekorat√∏rer gir et fleksibelt alternativ til subklassing for √• utvide funksjonalitet.",,,
qa,"Lecture 11","Forklar kjernemekanismen i Observer-m√∏nsteret.","I Observer-m√∏nsteret har man et ""observable""-objekt som opprettholder en liste over ""observer""-objekter. N√•r noe interessant skjer i ""observable""-objektet, varsler det alle registrerte ""observer""-objekter ved √• kalle en spesifikk metode (definert i et felles grensesnitt) p√• hver av dem. Det er et adferdsm√∏nster der et objekt (subjekt eller observable) vedlikeholder en liste over sine avhengige (observat√∏rer) og varsler dem automatisk om eventuelle tilstandsendringer.",,,
qa,"Lecture 11","Hva er en endelig tilstandsmaskin?","En endelig tilstandsmaskin er en beregningsmodell som til enhver tid befinner seg i √©n av et endelig antall mulige tilstander. Maskinens respons p√• input avhenger av den n√•v√¶rende tilstanden, og etter √• ha utf√∏rt en operasjon, transiterer maskinen til en annen tilstand (eller forblir i samme tilstand). Den best√•r av et endelig antall tilstander, overganger mellom disse tilstandene, og handlinger som kan utf√∏res ved overganger eller i bestemte tilstander.",,,
mc,"Lecture 11","Hva kjennetegner et designm√∏nster sammenlignet med en spesifikk algoritme?",,"Et designm√∏nster er en detaljert oppskrift for √• l√∏se et problem. |Et designm√∏nster er en spesifikk implementasjon i et gitt programmeringsspr√•k.|Et designm√∏nster er en generell veiledning for √• strukturere kode for √• l√∏se et tilbakevendende problem. |Et designm√∏nster er en ferdiglaget programvarekomponent som kan integreres direkte i et system.",2,"Det er en mal eller en veiledning for hvordan man kan strukturere kode for √• oppn√• visse egenskaper som fleksibilitet og vedlikeholdbarhet.\n\nAlternativ 'Et designm√∏nster er en detaljert oppskrift' beskriver mer en spesifikk algoritme, som er en rekke spesifikke steg for √• l√∏se et problem. Et designm√∏nster er en mer overordnet id√©.\nAlternativ 'Et designm√∏nster er en spesifikk implementasjon' er feil fordi et designm√∏nster er en abstrakt l√∏sning, ikke en ferdig implementasjon i et bestemt spr√•k. Det m√• tilpasses ulike situasjoner.\nAlternativ 'Et designm√∏nster er en ferdiglaget programvarekomponent' er ogs√• feil; et designm√∏nster er en mal eller veiledning, ikke en direkte implementerbar komponent. Man m√• strukturere kode ved hjelp av m√∏nsteret."
mc,"Lecture 11","Hva inneb√¶rer det n√•r en klasse ""implementerer"" et grensesnitt i Java?",,"Klassen arver automatisk alle metodene og deres implementasjon fra grensesnittet.|Klassen definerer sin egen versjon av alle metodene som er deklarert i grensesnittet.|Klassen kan velge √• implementere noen, men ikke n√∏dvendigvis alle metodene i grensesnittet. |Klassen oppretter en relasjon der den kan bruke konstantene definert i grensesnittet uten √• m√•tte implementere noen metoder.",1,"N√•r en klasse implementerer et grensesnitt, definerer klassen sin egen versjon av alle metodene som er deklarert i grensesnittet. Klassen inng√•r en ""kontrakt"" om √• tilby implementasjon for alle metodene.\n\nAlternativ 'Klassen arver automatisk alle metodene og deres implementasjon' er feil fordi et Java-grensesnitt definerer et sett med funksjonssignaturer uten implementasjon.\nAlternativ 'Klassen kan velge √• implementere noen' er feil; for √• fullt ut implementere grensesnittet, m√• klassen tilby implementasjon for alle de deklarerte metodene.\nAlternativ 'Klassen oppretter en relasjon der den kan bruke konstantene definert i grensesnittet uten √• m√•tte implementere noen metoder' er delvis riktig vedr√∏rende konstanter, men hovedbetydningen av √• implementere et grensesnitt er √• tilby implementasjon for de deklarerte metodene."
mc,"Lecture 11","Hvilket problem l√∏ser Adapter-m√∏nsteret prim√¶rt?",,"√Ö legge til ny funksjonalitet til et objekt dynamisk.|√Ö sikre at objekter kan kommunisere selv om de har ulike grensesnitt.|√Ö sentralisere logikken for tilstandsendringer i et objekt.|√Ö skape en familie av relaterte objekter uten √• spesifisere deres konkrete klasser.",1,"Adapter-m√∏nsteret l√∏ser prim√¶rt problemet med √• bruke en eksisterende klasse som ikke implementerer et n√∏dvendig grensesnitt, og dermed sikrer at klasser med inkompatible grensesnitt kan samarbeide. Adapteren konverterer grensesnittet til en klasse til et annet grensesnitt. \n\nAlternativ '√Ö legge til ny funksjonalitet til et objekt dynamisk' er hensikten med Dekorat√∏r-m√∏nsteret.\nAlternativ '√Ö sentralisere logikken for tilstandsendringer i et objekt' er relatert til State-m√∏nsteret.\nAlternativ '√Ö skape en familie av relaterte objekter uten √• spesifisere deres konkrete klasser' er kjennetegnet ved abstrakte fabrikk-m√∏nstre (ikke eksplisitt nevnt som et av de presenterte m√∏nstrene i kildene)."
mc,"Lecture 11","Hvordan oppn√•r Decorator-m√∏nsteret sin hensikt?",,"Ved √• endre arvehierarkiet til eksisterende klasser.|Ved √• opprette en ny klasse som inneholder logikken for den ekstra funksjonaliteten og erstatter den opprinnelige klassen.|ed √• omslutte et objekt av den opprinnelige klassen og delegere kall til det, samtidig som det legger til egen funksjonalitet.|Ved √• bruke betingelseslogikk inne i de eksisterende metodene for √• aktivere den nye funksjonaliteten ved behov.",2,"Decorator-m√∏nsteret oppn√•r sin hensikt ved √• lage en dekoratorklasse som omslutter en instans av den opprinnelige klassen og delegerer metodekall til den, samtidig som den utf√∏rer den ekstra handlingen f√∏r og/eller etter delegeringen. Det legger dynamisk til ansvar til et objekt.\n\nAlternativ 'Ved √• endre arvehierarkiet' er ikke hvordan Decorator-m√∏nsteret fungerer; det bruker komposisjon ved √• omslutte objektet.\nAlternativ 'Ved √• opprette en ny klasse som inneholder logikken for den ekstra funksjonaliteten og erstatter den opprinnelige klassen' kan ligne p√• subklassing, som Decorator er et mer fleksibelt alternativ til, men beskriver ikke kjernemekanismen.\nAlternativ 'Ved √• bruke betingelseslogikk inne i de eksisterende metodene' gj√∏r koden vanskeligere √• vedlikeholde og er ikke Decorator-m√∏nsterets tiln√¶rming for √• legge til funksjonalitet."
mc,"Lecture 11","Hva er en viktig konsekvens av bruken av grensesnitt i forbindelse med Adapter- og Decorator-m√∏nstrene?",,"Det reduserer behovet for testing av de implementerende klassene.|Det √∏ker kompleksiteten i systemet p√• grunn av flere abstrakte lag. |Det bidrar til √∏kt fleksibilitet og kombinerbarhet av adaptere og dekorat√∏rer. |Det l√•ser implementasjonen av de tilpassede eller dekorerte klassene til spesifikke grensesnitt.",2,"Bruk av grensesnitt gj√∏r at adaptere og dekorat√∏rer kan jobbe med alle klasser som implementerer det spesifikke grensesnittet, ikke bare √©n bestemt klasse, noe som bidrar til √∏kt fleksibilitet og kombinerbarhet. Man kan kombinere ulike adaptere og dekorat√∏rer i forskjellige rekkef√∏lger.\n\nAlternativ 'Det reduserer behovet for testing' er ikke en direkte konsekvens av bruken av grensesnitt i disse m√∏nstrene. Tvert imot kan det v√¶re behov for testing av de nye adapterne og dekorat√∏rene.\nAlternativ 'Det √∏ker kompleksiteten i systemet' kan potensielt skje med mange lag av abstraksjon, men hovedfordelen med fleksibilitet oppveier ofte dette.\nAlternativ 'Det l√•ser implementasjonen' er feil; grensesnitt fremmer l√∏sere kobling ved √• definere en kontrakt som flere klasser kan implementere."
mc,"Lecture 11","Hva er den prim√¶re rollen til ""observable""-objektet i Observer-m√∏nsteret?",,"√Ö definere grensesnittet som observat√∏rene m√• implementere.|√Ö utf√∏re handlinger basert p√• tilbakemeldinger fra observat√∏rene.|√Ö vedlikeholde en liste over observat√∏rer og varsle dem om relevante tilstandsendringer.|√Ö presentere data p√• en bestemt m√•te for observat√∏rene.",2,"Den prim√¶re rollen til ""observable""-objektet er √• opprettholde en liste over ""observer""-objekter og varsle dem automatisk om eventuelle tilstandsendringer. Dette skjer typisk ved √• kalle en spesifikk metode (definert i et felles grensesnitt) p√• hver av dem.\n\nAlternativ '√Ö definere grensesnittet som observat√∏rene m√• implementere' er vanligvis en separat oppgave. Grensesnittet definerer kontrakten mellom observable og observer. \nAlternativ '√Ö utf√∏re handlinger basert p√• tilbakemeldinger fra observat√∏rene' kan forekomme, men er ikke den definerende rollen til det observable objektet i selve varslingsmekanismen.\nAlternativ '√Ö presentere data p√• en bestemt m√•te for observat√∏rene' er mer relatert til hva observat√∏rene gj√∏r med informasjonen de mottar, ikke observable-objektets kjernefunksjon."
qa,"Lecture 13","Hvilket problem l√∏ser Builder-m√∏nsteret, og hvordan oppn√•r det dette?","Builder-m√∏nsteret l√∏ser problemet med √• opprette instanser av immutable klasser n√•r ikke all informasjon er tilgjengelig samtidig. Det introduserer en separat builder-klasse med settere som returnerer builder-objektet, slik at man trinnvis kan konfigurere objektet f√∏r den immutable instansen opprettes via en build()-metode.",,,
qa,"Lecture 13","Forklar hvordan Factory-m√∏nsteret kan brukes for √• lage instanser av en type T n√•r man ikke kan bruke new T() direkte.","Factory-m√∏nsteret omg√•r begrensningen ved new T() ved √• la en klasse A ta en fabrikkfunksjon (for eksempel en Supplier<T>) som parameter i konstrukt√∏ren. Denne funksjonen kan deretter kalles av A for √• opprette nye instanser av T uten at A selv trenger √• kjenne den konkrete typen.",,,
qa,"Lecture 13","Hva er hovedprinsippet bak Dependency Injection-m√∏nsteret, og hvorfor gj√∏r dette koden mer testbar?","Hovedprinsippet bak Dependency Injection er at en klasse tar sine avhengigheter (andre objekter den trenger for √• fungere) som parametre i konstrukt√∏ren, i stedet for √• opprette dem selv. Dette gj√∏r koden mer testbar fordi man kan injisere ""mock""-objekter under testing for √• isolere enheten som testes.",,,
qa,"Lecture 13","Gi et eksempel p√• et ""magisk tall"" eller en ""magisk streng"" og forklar hvorfor dette anses som en antipattern.","Et eksempel p√• et magisk tall er tallet 7 brukt i koden uten noen forklarende variabelnavn eller kommentar som indikerer hva det representerer (f.eks., antall dager i uken). Dette er en antipattern fordi det gj√∏r koden vanskeligere √• forst√• og vedlikeholde, da betydningen av tallet ikke er umiddelbart klar.",,,
qa,"Lecture 13","Hva er forskjellen p√• lav kohesjon og h√∏y kobling, og hvorfor er dette en u√∏nsket tilstand i kode?","Lav kohesjon betyr at en klasse inneholder kode som ikke logisk h√∏rer sammen eller tjener ulike form√•l, mens h√∏y kobling betyr at det er mange avhengigheter mellom ulike klasser. Dette er en u√∏nsket tilstand fordi det gj√∏r koden vanskeligere √• forst√•, endre og teste, da endringer i √©n klasse kan ha utilsiktede effekter i mange andre klasser.",,,
qa,"Lecture 13","Beskriv det grunnleggende konseptet for caching og forklar avveiningen som gj√∏res ved bruk av cache.","Caching er en teknikk for √• lagre resultater av tidligere beregninger eller data som er hentet, slik at de kan hentes raskt ved senere foresp√∏rsler uten √• m√•tte utf√∏re beregningen p√• nytt. Avveiningen er at man bruker mer minne eller diskplass for √• oppn√• raskere kj√∏retid.",,,
mc,"Lecture 13","Hva er hovedform√•let med Builder-m√∏nsteret?",," √Ö definere et grensesnitt for √• opprette objekter, men la subklasser bestemme hvilken klasse som skal instansieres.|√Ö konstruere komplekse objekter stegvis ved hjelp av en separat klasse.|√Ö sikre at en klasse bare har √©n instans.|√Ö definere et en-til-mange avhengighetsforhold mellom objekter.",1,"Hovedform√•let med Builder-m√∏nsteret er √• konstruere komplekse objekter stegvis ved hjelp av en separat klasse. Dette muliggj√∏r opprettelse av immutable objekter selv n√•r ikke all n√∏dvendig informasjon er tilgjengelig samtidig.\n\nAlternativ '√Ö definere et grensesnitt for √• opprette objekter' beskriver Factory-m√∏nsteret.\nAlternativ '√Ö sikre at en klasse bare har √©n instans' beskriver Singleton-m√∏nsteret (ikke nevnt i kildene). \nAlternativ '√Ö definere et en-til-mange avhengighetsforhold mellom objekter' beskriver Observer-m√∏nsteret (ikke nevnt i kildene)."
mc,"Lecture 13","Hvilket av f√∏lgende beskriver best hensikten med Factory-m√∏nsteret?",,"√Ö redusere koblingen mellom klasser ved √• injisere avhengigheter.|√Ö gjenbruke kode ved √• definere felles funksjonalitet i en superklasse.|√Ö abstrahere prosessen med √• opprette objekter uten √• spesifisere den eksakte klassen som opprettes.|√Ö kontrollere tilgangen til et objekt.",2,"Hensikten med Factory-m√∏nsteret er best beskrevet som √• abstrahere prosessen med √• opprette objekter uten √• spesifisere den eksakte klassen som opprettes. Dette tillater fleksibilitet i objektgenereringen.\n\nAlternativ '√Ö redusere koblingen mellom klasser ved √• injisere avhengigheter' beskriver Dependency Injection.\nAlternativ '√Ö gjenbruke kode ved √• definere felles funksjonalitet i en superklasse' beskriver arv (ikke et spesifikt designm√∏nster definert i kildene p√• denne m√•ten).\nAlternativ '√Ö kontrollere tilgangen til et objekt' kan referere til Proxy-m√∏nsteret (ikke nevnt i kildene)."
mc,"Lecture 13","Hvorfor gj√∏r Dependency Injection koden mer testbar?",,"Fordi det reduserer antall klasser og dermed mengden kode som m√• testes.|ordi avhengigheter mottas utenfra, noe som gj√∏r det mulig √• erstatte reelle avhengigheter med test-dobler (mocks).|Fordi det automatisk genererer testcases basert p√• klassens struktur.|Fordi det √∏ker kohesjonen i klassene.",1,"Dependency Injection gj√∏r koden mer testbar fordi avhengigheter mottas utenfra, noe som gj√∏r det mulig √• erstatte reelle avhengigheter med test-dobler (mocks). Dette isolerer koden som testes.\n\nAlternativ 'Fordi det reduserer antall klasser' er ikke en direkte konsekvens av Dependency Injection.\nAlternativ 'Fordi det automatisk genererer testcases' er ikke relatert til Dependency Injection. \nAlternativ 'Fordi det √∏ker kohesjonen i klassene' er en √∏nskelig egenskap i seg selv, men ikke den prim√¶re grunnen til √∏kt testbarhet ved Dependency Injection."
mc,"Lecture 13","Hva kjennetegner en ""magisk streng"" i kode?",,"En konstant streng som brukes p√• mange forskjellige steder i koden. |En strengliteral som vises direkte i koden uten en klar forklaring p√• dens betydning.|En streng som genereres dynamisk basert p√• brukerinput.|En streng som brukes til kryptering eller sikkerhetsform√•l.",1,"En ""magisk streng"" kjennetegnes av en strengliteral som vises direkte i koden uten en klar forklaring p√• dens betydning. Likt som med ""magiske tall"", gj√∏r dette koden vanskeligere √• forst√• og vedlikeholde.\n\nAlternativ 'En konstant streng som brukes p√• mange forskjellige steder i koden' kan v√¶re problematisk hvis betydningen ikke er klar, men definisjonen av en ""magisk streng"" fokuserer mer p√• mangelen p√• forklaring.\nAlternativ 'En streng som genereres dynamisk basert p√• brukerinput' er ikke n√∏dvendigvis en ""magisk streng"".\nAlternativ 'En streng som brukes til kryptering eller sikkerhetsform√•l' har en spesifikk hensikt og er ikke i seg selv en ""magisk streng""."
mc,"Lecture 13","Hvorfor er en ""eviction policy"" viktig for en cache som forventes √• vare over tid?",,"For √• sikre at dataene i cachen alltid er 100% oppdatert.|For √• hindre at cachen vokser ubegrenset og t√∏mmer tilgjengelig minne eller diskplass.|For √• forbedre sikkerheten ved √• fjerne sensitive data fra cachen regelmessig.|For √• redusere kompleksiteten i cache-implementasjonen.",1,"En ""eviction policy"" er viktig for en langvarig cache for √• hindre at cachen vokser ubegrenset og t√∏mmer tilgjengelig minne eller diskplass. Den definerer regler for hvilke elementer som skal fjernes n√•r kapasitetsgrensen n√•s.\n\n Alternativ 'For √• sikre at dataene i cachen alltid er 100% oppdatert' er ikke hovedform√•let med en eviction policy; det handler mer om cache invalidation.\n Alternativ 'For √• forbedre sikkerheten' kan v√¶re en sideeffekt i noen tilfeller, men ikke hovedform√•let.\n Alternativ 'For √• redusere kompleksiteten' er feil; en eviction policy legger til kompleksitet."
mc,"Lecture 13","Hvilken funksjon har `Cache-Control`-headeren i HTTP?",,"√Ö autentisere klienten som sender foresp√∏rselen. |√Ö spesifisere formatet p√• dataene som overf√∏res. |√Ö indikere for en klient hvordan et svar kan caches og hvor lenge. |√Ö h√•ndtere feilmeldinger fra serveren.",2,"Cache-Control-headeren i HTTP har funksjonen √• indikere for en klient hvordan et svar kan caches og hvor lenge. Direktiver som max-age brukes for dette.\n\nAlternativ '√Ö autentisere klienten' gj√∏res vanligvis med andre headere som Authorization. \nAlternativ '√Ö spesifisere formatet p√• dataene' gj√∏res med headere som Content-Type. \nAlternativ '√Ö h√•ndtere feilmeldinger fra serveren' er statuskoders og eventuelt en body sin oppgave, ikke Cache-Control-headeren."
