<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Flashcard App</title>
		<style>
			/* Base styles */
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			}

			body {
				background-color: #f3f4f6;
				min-height: 100vh;
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 2rem 1rem;
			}

			.container {
				max-width: 800px;
				width: 100%;
				display: flex;
				flex-direction: column;
				align-items: center;
			}

			h1 {
				font-size: 1.875rem;
				font-weight: 700;
				margin-bottom: 1.5rem;
				color: #111827;
			}

			/* Buttons */
			.button-group {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
				margin-bottom: 1.5rem;
				justify-content: center;
			}

			button {
				padding: 0.5rem 1rem;
				border-radius: 0.375rem;
				border: none;
				cursor: pointer;
				font-weight: 500;
				transition: background-color 0.2s;
			}

			.btn-primary {
				background-color: #3b82f6;
				color: white;
			}

			.btn-primary:hover {
				background-color: #2563eb;
			}

			.btn-success {
				background-color: #10b981;
				color: white;
			}

			.btn-success:hover {
				background-color: #059669;
			}

			.btn-danger {
				background-color: #ef4444;
				color: white;
			}

			.btn-danger:hover {
				background-color: #dc2626;
			}

			.btn-secondary {
				background-color: #9ca3af;
				color: white;
			}

			.btn-secondary:hover {
				background-color: #6b7280;
			}

			.btn-purple {
				background-color: #8b5cf6;
				color: white;
			}

			.btn-purple:hover {
				background-color: #7c3aed;
			}

			.btn-indigo {
				background-color: #6366f1;
				color: white;
			}

			.btn-indigo:hover {
				background-color: #4f46e5;
			}

			.btn-sm {
				padding: 0.25rem 0.5rem;
				font-size: 0.875rem;
			}

			.btn-gray {
				background-color: #e5e7eb;
				color: #374151;
			}

			.btn-gray:hover {
				background-color: #d1d5db;
			}

			.btn-blue-light {
				background-color: #dbeafe;
				color: #1e40af;
			}

			.btn-blue-light:hover {
				background-color: #bfdbfe;
			}

			.btn-red-light {
				background-color: #fee2e2;
				color: #b91c1c;
			}

			.btn-red-light:hover {
				background-color: #fecaca;
			}

			.btn-icon {
				display: flex;
				align-items: center;
				gap: 0.25rem;
			}

			.btn-full {
				width: 100%;
				margin-top: 1rem;
			}

			.btn-flex {
				flex: 1;
			}

			/* Show answer button - larger size */
			.btn-show-answer {
				height: 5rem;
				font-size: 1.25rem;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 600;
				transition: all 0.2s ease;
				margin-top: 1rem;
				margin-bottom: 1rem;
			}

			.btn-show-answer:hover {
				transform: scale(1.02);
			}

			/* Navigation buttons */
			.navigation-buttons {
				display: flex;
				justify-content: space-between;
				gap: 0.5rem;
				margin-top: 1rem;
			}

			.navigation-buttons button {
				flex: 1;
			}

			/* Card containers */
			.card {
				background-color: white;
				padding: 1.5rem;
				border-radius: 0.5rem;
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
				width: 100%;
				max-width: 32rem;
			}

			/* Form elements */
			.form-group {
				margin-bottom: 1rem;
			}

			label {
				display: block;
				margin-bottom: 0.5rem;
				font-weight: 500;
				color: #374151;
			}

			input[type='text'],
			textarea,
            select {
				width: 100%;
				padding: 0.5rem;
				border: 1px solid #d1d5db;
				border-radius: 0.375rem;
				font-size: 1rem;
			}

			textarea {
				resize: vertical;
				min-height: 5rem;
			}

			.radio-group {
				display: flex;
				gap: 1rem;
			}

			.radio-item {
				display: flex;
				align-items: center;
			}

			.radio-item input {
				margin-right: 0.5rem;
			}
            
            .checkbox-item {
                display: flex;
                align-items: center;
                cursor: pointer;
                user-select: none;
                padding: 0.5rem;
                background-color: #f3f4f6;
                border-radius: 0.375rem;
            }
            
            .checkbox-item input {
                margin-right: 0.5rem;
            }

			.option-item {
				display: flex;
				margin-bottom: 0.5rem;
				align-items: center;
			}

			.option-item input[type='radio'] {
				margin-right: 0.5rem;
			}

			.option-item input[type='text'] {
				flex-grow: 1;
			}

			.option-item button {
				margin-left: 0.5rem;
				color: #ef4444;
				background: none;
				border: none;
				font-size: 1.25rem;
				cursor: pointer;
			}

			/* Card list */
			.card-list {
				margin-top: 1.5rem;
			}

			.card-list-header {
				font-weight: 700;
				margin-bottom: 0.5rem;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.card-list-container {
				max-height: 15rem;
				overflow-y: auto;
				border: 1px solid #e5e7eb;
				border-radius: 0.375rem;
			}

			.card-item {
				padding: 0.5rem;
				margin-bottom: 0.5rem;
				background-color: #f9fafb;
				border-radius: 0.375rem;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.card-item-details h3 {
				font-weight: 500;
				margin-bottom: 0.25rem;
			}

			.card-item-details p {
				font-size: 0.875rem;
				color: #6b7280;
			}

			.card-topic {
				font-size: 0.75rem;
				font-weight: 600;
				color: #4b5563;
				background-color: #e5e7eb;
				padding: 0.15rem 0.5rem;
				border-radius: 0.25rem;
				display: inline-block;
				margin-bottom: 0.25rem;
			}

			/* View Cards Page */
			.topic-section {
				margin-bottom: 2rem;
				border: 1px solid #e5e7eb;
				border-radius: 0.5rem;
				overflow: hidden;
			}

			.topic-header {
				background-color: #f3f4f6;
				padding: 0.75rem 1rem;
				font-weight: 600;
				font-size: 1.125rem;
				color: #111827;
				border-bottom: 1px solid #e5e7eb;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
            
            .topic-header-actions {
                display: flex;
                gap: 0.5rem;
                align-items: center;
            }

			.topic-header-count {
				font-size: 0.875rem;
				color: #6b7280;
				font-weight: normal;
			}

			.topic-cards {
				padding: 0.5rem;
			}

			.view-card-item {
				background-color: white;
				border: 1px solid #e5e7eb;
				border-radius: 0.375rem;
				margin-bottom: 0.5rem;
				padding: 0.75rem;
			}

			.view-card-question {
				font-weight: 500;
				margin-bottom: 0.5rem;
			}

			.view-card-type {
				font-size: 0.75rem;
				color: #6b7280;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.view-card-actions {
				display: flex;
				gap: 0.5rem;
			}

			.no-topics-message {
				text-align: center;
				padding: 2rem;
				color: #6b7280;
			}

			.card-item-actions {
				display: flex;
				gap: 0.5rem;
			}

			/* Quiz card styling */
			.quiz-card {
				text-align: center;
			}

			.quiz-card-header {
				font-size: 0.875rem;
				color: #6b7280;
				margin-bottom: 1rem;
			}

			.quiz-card-topic {
				display: inline-block;
				background-color: #e5e7eb;
				color: #4b5563;
				font-size: 0.875rem;
				font-weight: 600;
				padding: 0.25rem 0.75rem;
				border-radius: 0.375rem;
				margin-bottom: 0.75rem;
			}

			.quiz-card-question {
				font-size: 1.25rem;
				font-weight: 700;
				margin-bottom: 1rem;
			}

			.quiz-option {
				padding: 0.75rem;
				border: 1px solid #d1d5db;
				border-radius: 0.375rem;
				margin-bottom: 0.5rem;
				cursor: pointer;
				text-align: left;
				transition: all 0.2s;
			}

			.quiz-option:hover {
				background-color: #f3f4f6;
			}

			.quiz-option.correct {
				background-color: #d1fae5;
				border-color: #10b981;
			}

			.quiz-option.incorrect {
				background-color: #fee2e2;
				border-color: #ef4444;
			}

			.answer-section {
				margin-top: 1rem;
				padding: 1rem;
				background-color: #d1fae5;
				border-radius: 0.375rem;
			}

			.answer-section p:first-child {
				font-weight: 600;
				margin-bottom: 0.5rem;
			}
			.answer-section p:last-child {
				white-space: pre-wrap;
				text-align: left;
			}

			/* Form actions */
			.form-actions {
				display: flex;
				gap: 0.5rem;
			}

			/* File input styling */
			.file-input {
				display: none;
			}

			/* Notification */
			.notification {
				position: fixed;
				top: 1rem;
				right: 1rem;
				padding: 0.75rem;
				border-radius: 0.375rem;
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
				display: flex;
				align-items: center;
				gap: 0.5rem;
				max-width: 20rem;
				z-index: 50;
				animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
				opacity: 0;
			}

			.notification.error {
				background-color: #fee2e2;
				color: #b91c1c;
			}

			.notification.success {
				background-color: #d1fae5;
				color: #065f46;
			}

			.notification.info {
				background-color: #dbeafe;
				color: #1e40af;
			}

			@keyframes fadeIn {
				from {
					opacity: 0;
				}
				to {
					opacity: 1;
				}
			}

			@keyframes fadeOut {
				from {
					opacity: 1;
				}
				to {
					opacity: 0;
				}
			}

			/* Utility classes */
			.mt-2 {
				margin-top: 0.5rem;
			}

			.mt-4 {
				margin-top: 1rem;
			}

			.mr-2 {
				margin-right: 0.5rem;
			}
            
            .ml-2 {
                margin-left: 0.5rem;
            }

			.hidden {
				display: none !important;
			}

			.space-y-2 > * + * {
				margin-top: 0.5rem;
			}

			/* Icons */
			.icon {
				width: 1em;
				height: 1em;
				vertical-align: middle;
				fill: currentColor;
				overflow: hidden;
			}

			/* Auto-save indicator */
			.autosave-indicator {
				font-size: 0.75rem;
				color: #6b7280;
				text-align: center;
				margin-top: 0.5rem;
			}

			/* Disabled button */
			button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}

			/* Modal dialog */
			.modal-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 100;
			}

			.modal-content {
				background-color: white;
				padding: 1.5rem;
				border-radius: 0.5rem;
				max-width: 24rem;
				width: 100%;
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			}

			.modal-title {
				font-size: 1.25rem;
				font-weight: 600;
				margin-bottom: 1rem;
				color: #111827;
			}

			.modal-message {
				margin-bottom: 1.5rem;
				color: #4b5563;
			}

			.modal-actions {
				display: flex;
				flex-direction: column;
				gap: 0.5rem;
			}

			/* Progress bar */
			.progress-container {
				width: 100%;
				height: 0.5rem;
				background-color: #e5e7eb;
				border-radius: 0.25rem;
				margin-bottom: 1rem;
				overflow: hidden;
			}

			.progress-bar {
				height: 100%;
				background-color: #3b82f6;
				transition: width 0.3s ease;
			}

			/* Quiz statistics */
			.quiz-stats {
				margin-top: 1.5rem;
				padding: 1rem;
				background-color: #f8fafc;
				border-radius: 0.375rem;
				border: 1px solid #e2e8f0;
			}

			.quiz-stats h3 {
				font-size: 1.125rem;
				font-weight: 600;
				margin-bottom: 0.5rem;
				color: #334155;
			}

			.quiz-stats p {
				margin-bottom: 0.25rem;
				color: #475569;
			}
            
            /* Quiz topic header */
            .quiz-topic-header {
                background-color: #f0f9ff;
                border-radius: 0.375rem;
                padding: 0.75rem;
                margin-bottom: 1rem;
                text-align: center;
                border: 1px solid #bae6fd;
                color: #0369a1;
            }

			/* Keyboard shortcuts hint */
			.keyboard-hint {
				font-size: 0.75rem;
				color: #6b7280;
				text-align: center;
				margin-top: 0.5rem;
				border-top: 1px solid #e5e7eb;
				padding-top: 0.5rem;
			}

			/* Edit button in quiz mode */
			.quiz-edit-button {
				position: absolute;
				top: 0.5rem;
				right: 0.5rem;
				background-color: #dbeafe;
				color: #1e40af;
				padding: 0.25rem 0.5rem;
				border-radius: 0.25rem;
				font-size: 0.75rem;
				cursor: pointer;
			}

			.quiz-edit-button:hover {
				background-color: #bfdbfe;
			}

			.quiz-card-container {
				position: relative;
			}

			/* Edit card modal */
			.edit-card-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 100;
			}

			.edit-card-modal-content {
				background-color: white;
				padding: 1.5rem;
				border-radius: 0.5rem;
				max-width: 32rem;
				width: 95%;
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
				max-height: 90vh;
				overflow-y: auto;
			}
            
            /* ADDED: Sections with larger max-width */
            #viewCardsSection, #quizSection, #addCardSection {
                max-width: 100rem !important;
            }
            
            /* ADDED: Grid layout for topic sections */
            #topicSections {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
            
            /* ADDED: View mode control styles */
            #gridSizeSelect {
                display: inline-block;
                width: auto;
                vertical-align: middle;
            }
		</style>
		</style>
		</style>
	</head>
	<body>
		<div class="container" id="app">
			<h1>Flashcard App</h1>

			<div class="button-group">
				<button id="addCardsBtn" class="btn-primary">Add Cards</button>
				<button id="viewCardsBtn" class="btn-secondary">View Cards</button>
				<button id="startQuizBtn" class="btn-success">Start Quiz</button>
                <div>
                    <label class="checkbox-item">
                        <input type="checkbox" id="randomizeCardsCheckbox" checked />
                        <span>Randomize Cards</span>
                    </label>
                </div>

				<div>
					<button id="importBtn" class="btn-purple btn-icon">
						<svg class="icon" viewBox="0 0 24 24" width="16" height="16">
							<path d="M8 17L12 21M12 21L16 17M12 21V3M20 17V20C20 20.5523 19.5523 21 19 21H5C4.44772 21 4 20.5523 4 20V17"></path>
						</svg>
						Import
					</button>
					<input type="file" id="fileInput" class="file-input" accept=".csv,.txt,.json" />

					<button id="exportBtn" class="btn-indigo btn-icon">
						<svg class="icon" viewBox="0 0 24 24" width="16" height="16">
							<path d="M8 7L12 3M12 3L16 7M12 3V21M20 7V4C20 3.44772 19.5523 3 19 3H5C4.44772 3 4 3.44772 4 4V7"></path>
						</svg>
						Export
					</button>
				</div>
			</div>

			<!-- Add/Edit Card Section -->
			<div id="addCardSection" class="card">
				<h2 id="formTitle" class="form-group">Add New Flashcard</h2>

				<div class="form-group">
					<label>Card Type:</label>
					<div class="radio-group">
						<label class="radio-item"> <input type="radio" name="cardType" value="qa" checked /> Question/Answer </label>
						<label class="radio-item"> <input type="radio" name="cardType" value="mc" /> Multiple Choice </label>
					</div>
				</div>

				<div class="form-group">
					<label for="topicInput">Topic:</label>
					<input type="text" id="topicInput" placeholder="Enter a topic (e.g. Math, History, Science)" />
				</div>

				<div class="form-group">
					<label for="questionInput">Question:</label>
					<textarea id="questionInput" rows="3"></textarea>
				</div>

				<!-- QA Type fields -->
				<div id="qaFields" class="form-group">
					<label for="answerInput">Answer:</label>
					<textarea id="answerInput" rows="3"></textarea>
				</div>

				<!-- MC Type fields -->
				<div id="mcFields" class="form-group hidden">
					<label>Options:</label>
					<div id="optionsContainer">
						<!-- Option items will be added here dynamically -->
					</div>

					<button id="addOptionBtn" class="btn-sm btn-gray mt-2">+ Add Option</button>

					<div class="form-group mt-4">
						<label for="explanationInput">Explanation (for correct answer):</label>
						<textarea id="explanationInput" rows="3"></textarea>
					</div>
				</div>

				<div class="form-actions">
					<button id="saveCardBtn" class="btn-primary btn-flex">Add Card</button>
					<button id="cancelEditBtn" class="btn-secondary btn-flex hidden">Cancel</button>
				</div>

				<div class="card-list">
					<div class="card-list-header">
						<h3>Recently Added Cards:</h3>
					</div>
					<div id="cardListContainer" class="card-list-container">
						<!-- Card items will be added here dynamically -->
					</div>
				</div>

				<div id="autosaveIndicator" class="autosave-indicator"></div>
			</div>

			<!-- View Cards Section -->
			<div id="viewCardsSection" class="card hidden">
				<h2 class="form-group">Your Flashcards (<span id="totalCardCount">0</span>)</h2>

				<div class="button-group">
					<button id="viewAddCardBtn" class="btn-primary">Add New Card</button>
					<button id="clearAllCardsBtn" class="btn-danger">Clear All Cards</button>
                    <div>
                        <span>Columns: </span>
                        <select id="gridSizeSelect" class="ml-2">
                            <option value="1">1</option>
                            <option value="2" selected>2</option>
                            <option value="3">3</option>
                        </select>
                    </div>
				</div>

				<div id="topicSections" class="mt-4">
					<!-- Topic sections will be added here dynamically -->
				</div>
			</div>

			<!-- Quiz Section -->
			<div id="quizSection" class="card hidden">
				<div class="progress-container">
					<div id="progressBar" class="progress-bar" style="width: 0%"></div>
				</div>

				<div id="quizCardContainer" class="quiz-card-container">
					<!-- Quiz card will be rendered here -->
				</div>

				<div class="keyboard-hint">Keyboard shortcuts: ← Previous card | → Next card | Space Show/Hide answer</div>
			</div>

			<!-- Clear All Confirmation Modal -->
			<div id="clearConfirmModal" class="modal-overlay hidden">
				<div class="modal-content">
					<h3 class="modal-title">Clear All Flashcards</h3>
					<p class="modal-message">Are you sure you want to delete all flashcards? This action cannot be undone.</p>
					<div class="modal-actions">
						<button id="exportFirstBtn" class="btn-indigo">Export First, Then Clear</button>
						<button id="clearConfirmBtn" class="btn-danger">Yes, Clear All Cards</button>
						<button id="clearCancelBtn" class="btn-secondary">Cancel</button>
					</div>
				</div>
			</div>

			<!-- Edit Card Modal (for quiz mode) -->
			<div id="editCardModal" class="edit-card-modal hidden">
				<div class="edit-card-modal-content">
					<h3 class="modal-title">Edit Flashcard</h3>

					<div class="form-group">
						<label>Card Type:</label>
						<div class="radio-group">
							<label class="radio-item"> <input type="radio" name="modalCardType" value="qa" checked /> Question/Answer </label>
							<label class="radio-item"> <input type="radio" name="modalCardType" value="mc" /> Multiple Choice </label>
						</div>
					</div>

					<div class="form-group">
						<label for="modalTopicInput">Topic:</label>
						<input type="text" id="modalTopicInput" placeholder="Enter a topic (e.g. Math, History, Science)" />
					</div>

					<div class="form-group">
						<label for="modalQuestionInput">Question:</label>
						<textarea id="modalQuestionInput" rows="3"></textarea>
					</div>

					<!-- QA Type fields -->
					<div id="modalQaFields" class="form-group">
						<label for="modalAnswerInput">Answer:</label>
						<textarea id="modalAnswerInput" rows="3"></textarea>
					</div>

					<!-- MC Type fields -->
					<div id="modalMcFields" class="form-group hidden">
						<label>Options:</label>
						<div id="modalOptionsContainer">
							<!-- Option items will be added here dynamically -->
						</div>

						<button id="modalAddOptionBtn" class="btn-sm btn-gray mt-2">+ Add Option</button>

						<div class="form-group mt-4">
							<label for="modalExplanationInput">Explanation (for correct answer):</label>
							<textarea id="modalExplanationInput" rows="3"></textarea>
						</div>
					</div>

					<div class="form-actions">
						<button id="modalSaveCardBtn" class="btn-primary btn-flex">Save Changes</button>
						<button id="modalCancelBtn" class="btn-secondary btn-flex">Cancel</button>
					</div>
				</div>
			</div>
		</div>

		<script>
			document.addEventListener('DOMContentLoaded', function () {
				// App State
				let cards = [];
				let currentPage = 'add'; // 'add', 'view', or 'quiz'
				let shuffledCards = [];
				let currentCardIndex = 0;
				let showAnswer = false;
				let editingCardId = null;
				let selectedOption = null;
				let lastAutoSaveTime = null;
				let quizStats = {
					cardsReviewed: 0,
					startTime: null,
					cardsTimes: [],
				};

				// DOM Elements
				const addCardSection = document.getElementById('addCardSection');
				const viewCardsSection = document.getElementById('viewCardsSection');
				const quizSection = document.getElementById('quizSection');
				const formTitle = document.getElementById('formTitle');
				const cardTypeRadios = document.getElementsByName('cardType');
				const qaFields = document.getElementById('qaFields');
				const mcFields = document.getElementById('mcFields');
				const optionsContainer = document.getElementById('optionsContainer');
				const questionInput = document.getElementById('questionInput');
				const topicInput = document.getElementById('topicInput');
				const answerInput = document.getElementById('answerInput');
				const explanationInput = document.getElementById('explanationInput');
				const saveCardBtn = document.getElementById('saveCardBtn');
				const cancelEditBtn = document.getElementById('cancelEditBtn');
				const addOptionBtn = document.getElementById('addOptionBtn');
				const cardListContainer = document.getElementById('cardListContainer');
				const topicSections = document.getElementById('topicSections');
				const totalCardCount = document.getElementById('totalCardCount');
				const quizCardContainer = document.getElementById('quizCardContainer');
				const fileInput = document.getElementById('fileInput');
				const autosaveIndicator = document.getElementById('autosaveIndicator');
				const progressBar = document.getElementById('progressBar');
				const clearConfirmModal = document.getElementById('clearConfirmModal');
				const clearConfirmBtn = document.getElementById('clearConfirmBtn');
				const clearCancelBtn = document.getElementById('clearCancelBtn');
				const exportFirstBtn = document.getElementById('exportFirstBtn');

				// Modal Elements
				const editCardModal = document.getElementById('editCardModal');
				const modalCardTypeRadios = document.getElementsByName('modalCardType');
				const modalQaFields = document.getElementById('modalQaFields');
				const modalMcFields = document.getElementById('modalMcFields');
				const modalOptionsContainer = document.getElementById('modalOptionsContainer');
				const modalTopicInput = document.getElementById('modalTopicInput');
				const modalQuestionInput = document.getElementById('modalQuestionInput');
				const modalAnswerInput = document.getElementById('modalAnswerInput');
				const modalExplanationInput = document.getElementById('modalExplanationInput');
				const modalSaveCardBtn = document.getElementById('modalSaveCardBtn');
				const modalCancelBtn = document.getElementById('modalCancelBtn');
				const modalAddOptionBtn = document.getElementById('modalAddOptionBtn');

				// Buttons
				const addCardsBtn = document.getElementById('addCardsBtn');
				const viewCardsBtn = document.getElementById('viewCardsBtn');
				const viewAddCardBtn = document.getElementById('viewAddCardBtn');
				const startQuizBtn = document.getElementById('startQuizBtn');
				const importBtn = document.getElementById('importBtn');
				const exportBtn = document.getElementById('exportBtn');
				const clearAllCardsBtn = document.getElementById('clearAllCardsBtn');
                const gridSizeSelect = document.getElementById('gridSizeSelect');
                const randomizeCardsCheckbox = document.getElementById('randomizeCardsCheckbox');

				// Initialize
				initializeOptionsContainer();
				updateCardType();
				loadFromLocalStorage();

				// Event Listeners
				cardTypeRadios.forEach((radio) => {
					radio.addEventListener('change', updateCardType);
				});

				modalCardTypeRadios.forEach((radio) => {
					radio.addEventListener('change', updateModalCardType);
				});

				addOptionBtn.addEventListener('click', addOption);
				modalAddOptionBtn.addEventListener('click', addModalOption);
				saveCardBtn.addEventListener('click', saveCard);
				modalSaveCardBtn.addEventListener('click', saveModalCard);
				cancelEditBtn.addEventListener('click', cancelEditing);
				modalCancelBtn.addEventListener('click', hideEditCardModal);

				// Navigation between pages
				addCardsBtn.addEventListener('click', () => {
					setCurrentPage('add');
					if (editingCardId) {
						cancelEditing();
					}
				});

				viewCardsBtn.addEventListener('click', () => {
					setCurrentPage('view');
					renderTopicSections();
                    
                    // Update grid columns
                    topicSections.style.gridTemplateColumns = `repeat(${gridSizeSelect.value}, 1fr)`;
				});

				viewAddCardBtn.addEventListener('click', () => {
					setCurrentPage('add');
				});

				startQuizBtn.addEventListener('click', () => startQuiz(null));
				importBtn.addEventListener('click', () => fileInput.click());
				fileInput.addEventListener('change', importCards);
				exportBtn.addEventListener('click', exportCards);
				clearAllCardsBtn.addEventListener('click', showClearConfirmation);
				clearConfirmBtn.addEventListener('click', clearAllCards);
				clearCancelBtn.addEventListener('click', hideClearConfirmation);
				exportFirstBtn.addEventListener('click', exportThenClear);

				// Also allow clicking outside the modals to close them
				clearConfirmModal.addEventListener('click', function (e) {
					if (e.target === clearConfirmModal) {
						hideClearConfirmation();
					}
				});

				editCardModal.addEventListener('click', function (e) {
					if (e.target === editCardModal) {
						hideEditCardModal();
					}
				});

				// Keyboard shortcuts
				document.addEventListener('keydown', handleKeyboardShortcuts);

				// Save when user leaves the page
				window.addEventListener('beforeunload', function (e) {
					// Always save to localStorage
					saveToLocalStorage();

					// This creates a confirmation dialog asking if user really wants to leave
					// (though most modern browsers ignore the custom message)
					if (cards.length > 0) {
						e.preventDefault();
						e.returnValue = 'Changes you made may not be saved. Are you sure you want to exit?';
					}
				});

				// Functions
				function updateCardType() {
					const cardType = getSelectedCardType();

					if (cardType === 'qa') {
						qaFields.classList.remove('hidden');
						mcFields.classList.add('hidden');
					} else {
						qaFields.classList.add('hidden');
						mcFields.classList.remove('hidden');
					}
				}

				function updateModalCardType() {
					const cardType = getSelectedModalCardType();

					if (cardType === 'qa') {
						modalQaFields.classList.remove('hidden');
						modalMcFields.classList.add('hidden');
					} else {
						modalQaFields.classList.add('hidden');
						modalMcFields.classList.remove('hidden');
					}
				}

				function getSelectedCardType() {
					for (const radio of cardTypeRadios) {
						if (radio.checked) {
							return radio.value;
						}
					}
					return 'qa'; // Default
				}

				function getSelectedModalCardType() {
					for (const radio of modalCardTypeRadios) {
						if (radio.checked) {
							return radio.value;
						}
					}
					return 'qa'; // Default
				}

				function initializeOptionsContainer() {
					optionsContainer.innerHTML = '';

					for (let i = 0; i < 4; i++) {
						addOptionElement('', i === 0);
					}
				}

				function initializeModalOptionsContainer() {
					modalOptionsContainer.innerHTML = '';

					for (let i = 0; i < 4; i++) {
						addModalOptionElement('', i === 0);
					}
				}

				function addOption() {
					addOptionElement('', false);
				}

				function addModalOption() {
					addModalOptionElement('', false);
				}

				function addOptionElement(value, isCorrect) {
					const optionIndex = optionsContainer.children.length;
					const optionDiv = document.createElement('div');
					optionDiv.className = 'option-item';

					const radioInput = document.createElement('input');
					radioInput.type = 'radio';
					radioInput.name = 'correctOption';
					radioInput.value = optionIndex;
					radioInput.checked = isCorrect;

					const textInput = document.createElement('input');
					textInput.type = 'text';
					textInput.value = value;
					textInput.placeholder = `Option ${optionIndex + 1}`;

					const removeBtn = document.createElement('button');
					removeBtn.textContent = '✕';
					removeBtn.addEventListener('click', () => removeOption(optionDiv));

					optionDiv.appendChild(radioInput);
					optionDiv.appendChild(textInput);
					optionDiv.appendChild(removeBtn);
					optionsContainer.appendChild(optionDiv);
				}

				function addModalOptionElement(value, isCorrect) {
					const optionIndex = modalOptionsContainer.children.length;
					const optionDiv = document.createElement('div');
					optionDiv.className = 'option-item';

					const radioInput = document.createElement('input');
					radioInput.type = 'radio';
					radioInput.name = 'modalCorrectOption';
					radioInput.value = optionIndex;
					radioInput.checked = isCorrect;

					const textInput = document.createElement('input');
					textInput.type = 'text';
					textInput.value = value;
					textInput.placeholder = `Option ${optionIndex + 1}`;

					const removeBtn = document.createElement('button');
					removeBtn.textContent = '✕';
					removeBtn.addEventListener('click', () => removeModalOption(optionDiv));

					optionDiv.appendChild(radioInput);
					optionDiv.appendChild(textInput);
					optionDiv.appendChild(removeBtn);
					modalOptionsContainer.appendChild(optionDiv);
				}

				function removeOption(optionElement) {
					if (optionsContainer.children.length <= 2) {
						showNotification('Multiple choice questions need at least 2 options', 'error');
						return;
					}

					optionsContainer.removeChild(optionElement);

					// Update option indices and check if correct option needs adjustment
					const correctOptionRadios = document.querySelectorAll('input[name="correctOption"]');
					let hasChecked = false;

					correctOptionRadios.forEach((radio, index) => {
						radio.value = index;
						if (radio.checked) {
							hasChecked = true;
						}
					});

					// If no option is selected as correct, select the first one
					if (!hasChecked && correctOptionRadios.length > 0) {
						correctOptionRadios[0].checked = true;
					}
				}

				function removeModalOption(optionElement) {
					if (modalOptionsContainer.children.length <= 2) {
						showNotification('Multiple choice questions need at least 2 options', 'error');
						return;
					}

					modalOptionsContainer.removeChild(optionElement);

					// Update option indices and check if correct option needs adjustment
					const correctOptionRadios = document.querySelectorAll('input[name="modalCorrectOption"]');
					let hasChecked = false;

					correctOptionRadios.forEach((radio, index) => {
						radio.value = index;
						if (radio.checked) {
							hasChecked = true;
						}
					});

					// If no option is selected as correct, select the first one
					if (!hasChecked && correctOptionRadios.length > 0) {
						correctOptionRadios[0].checked = true;
					}
				}

				function getOptions() {
					const options = [];
					const optionItems = optionsContainer.querySelectorAll('.option-item');

					optionItems.forEach((item) => {
						const textInput = item.querySelector('input[type="text"]');
						options.push(textInput.value);
					});

					return options;
				}

				function getModalOptions() {
					const options = [];
					const optionItems = modalOptionsContainer.querySelectorAll('.option-item');

					optionItems.forEach((item) => {
						const textInput = item.querySelector('input[type="text"]');
						options.push(textInput.value);
					});

					return options;
				}

				function getCorrectOptionIndex() {
					const selectedRadio = document.querySelector('input[name="correctOption"]:checked');
					return selectedRadio ? parseInt(selectedRadio.value) : 0;
				}

				function getModalCorrectOptionIndex() {
					const selectedRadio = document.querySelector('input[name="modalCorrectOption"]:checked');
					return selectedRadio ? parseInt(selectedRadio.value) : 0;
				}

				function saveCard() {
					const cardType = getSelectedCardType();
					const question = questionInput.value.trim();
					const topic = topicInput.value.trim();

					if (question === '') {
						showNotification('Please enter a question', 'error');
						return;
					}

					if (cardType === 'qa') {
						const answer = answerInput.value.trim();

						if (answer === '') {
							showNotification('Please enter an answer', 'error');
							return;
						}

						if (editingCardId) {
							updateExistingCard({
								id: editingCardId,
								type: cardType,
								topic: topic,
								question: question,
								answer: answer,
							});
						} else {
							addNewCard({
								id: Date.now(),
								type: cardType,
								topic: topic,
								question: question,
								answer: answer,
							});
						}
					} else {
						const options = getOptions();
						const validOptions = options.filter((opt) => opt.trim() !== '');
						const correctOption = getCorrectOptionIndex();
						const explanation = explanationInput.value.trim();

						if (validOptions.length < 2) {
							showNotification('Please provide at least 2 options', 'error');
							return;
						}

						if (options[correctOption].trim() === '') {
							showNotification('The correct option cannot be empty', 'error');
							return;
						}

						if (editingCardId) {
							updateExistingCard({
								id: editingCardId,
								type: cardType,
								topic: topic,
								question: question,
								options: validOptions,
								correctOption: correctOption,
								explanation: explanation,
							});
						} else {
							addNewCard({
								id: Date.now(),
								type: cardType,
								topic: topic,
								question: question,
								options: validOptions,
								correctOption: correctOption,
								explanation: explanation,
							});
						}
					}

					resetForm();
					renderCardList();

					// If we have the view cards page open, update that too
					if (currentPage === 'view') {
						renderTopicSections();
					}

					saveToLocalStorage();
				}

				function addNewCard(card) {
					cards.push(card);
					showNotification('Card added successfully!', 'success');
				}

				function updateExistingCard(updatedCard) {
					const index = cards.findIndex((card) => card.id === updatedCard.id);

					if (index !== -1) {
						cards[index] = updatedCard;
						showNotification('Card updated successfully!', 'success');
					}

					editingCardId = null;
					saveCardBtn.textContent = 'Add Card';
					formTitle.textContent = 'Add New Flashcard';
					cancelEditBtn.classList.add('hidden');
				}

				function startEditing(cardId) {
					const card = cards.find((c) => c.id === cardId);

					if (!card) return;

					editingCardId = card.id;
					saveCardBtn.textContent = 'Save Changes';
					formTitle.textContent = 'Edit Flashcard';
					cancelEditBtn.classList.remove('hidden');

					// Set card type
					cardTypeRadios.forEach((radio) => {
						radio.checked = radio.value === card.type;
					});
					updateCardType();

					// Set topic and question
					topicInput.value = card.topic || '';
					questionInput.value = card.question;

					if (card.type === 'qa') {
						answerInput.value = card.answer;
					} else {
						// Set multiple choice options
						optionsContainer.innerHTML = '';

						card.options.forEach((option, index) => {
							addOptionElement(option, index === card.correctOption);
						});

						// Add empty options if needed
						while (optionsContainer.children.length < 3) {
							addOptionElement('', false);
						}

						explanationInput.value = card.explanation || '';
					}

					// Scroll to form
					formTitle.scrollIntoView({ behavior: 'smooth' });
				}

				// Function to edit a card from quiz mode
				function editCurrentQuizCard() {
					if (!shuffledCards || shuffledCards.length === 0) return;

					const currentCard = shuffledCards[currentCardIndex];
					const originalCardId = currentCard.id;

					// Show edit modal for the current card
					showEditCardModal(originalCardId);
				}

				function showEditCardModal(cardId) {
					const card = cards.find((c) => c.id === cardId);
					if (!card) return;

					// Store the ID of the card being edited
					editingCardId = cardId;

					// Set card type in modal
					modalCardTypeRadios.forEach((radio) => {
						radio.checked = radio.value === card.type;
					});
					updateModalCardType();

					// Set topic and question in modal
					modalTopicInput.value = card.topic || '';
					modalQuestionInput.value = card.question;

					if (card.type === 'qa') {
						modalAnswerInput.value = card.answer;
					} else {
						// Set multiple choice options in modal
						modalOptionsContainer.innerHTML = '';

						card.options.forEach((option, index) => {
							addModalOptionElement(option, index === card.correctOption);
						});

						// Add empty options if needed
						while (modalOptionsContainer.children.length < 3) {
							addModalOptionElement('', false);
						}

						modalExplanationInput.value = card.explanation || '';
					}

					// Show the modal
					editCardModal.classList.remove('hidden');
				}

				function hideEditCardModal() {
					editCardModal.classList.add('hidden');
					editingCardId = null;
				}

				function saveModalCard() {
					const cardType = getSelectedModalCardType();
					const question = modalQuestionInput.value.trim();
					const topic = modalTopicInput.value.trim();

					if (question === '') {
						showNotification('Please enter a question', 'error');
						return;
					}

					if (cardType === 'qa') {
						const answer = modalAnswerInput.value.trim();

						if (answer === '') {
							showNotification('Please enter an answer', 'error');
							return;
						}

						if (editingCardId) {
							updateExistingCardFromModal({
								id: editingCardId,
								type: cardType,
								topic: topic,
								question: question,
								answer: answer,
							});
						}
					} else {
						const options = getModalOptions();
						const validOptions = options.filter((opt) => opt.trim() !== '');
						const correctOption = getModalCorrectOptionIndex();
						const explanation = modalExplanationInput.value.trim();

						if (validOptions.length < 2) {
							showNotification('Please provide at least 2 options', 'error');
							return;
						}

						if (options[correctOption].trim() === '') {
							showNotification('The correct option cannot be empty', 'error');
							return;
						}

						if (editingCardId) {
							updateExistingCardFromModal({
								id: editingCardId,
								type: cardType,
								topic: topic,
								question: question,
								options: validOptions,
								correctOption: correctOption,
								explanation: explanation,
							});
						}
					}

					hideEditCardModal();
					renderQuizCard(); // Refresh the current quiz card
				}

				function updateExistingCardFromModal(updatedCard) {
					const index = cards.findIndex((card) => card.id === updatedCard.id);

					if (index !== -1) {
						cards[index] = updatedCard;

						// Also update the card in the shuffled deck if we're in quiz mode
						if (currentPage === 'quiz') {
							const shuffledIndex = shuffledCards.findIndex((card) => card.id === updatedCard.id);
							if (shuffledIndex !== -1) {
								// For MC cards, preserve the shuffled order of options
								if (updatedCard.type === 'mc' && shuffledCards[shuffledIndex].type === 'mc') {
									// Find the correct answer value
									const correctAnswer = updatedCard.options[updatedCard.correctOption];

									// If the shuffled card has the same number of options, try to preserve order
									if (shuffledCards[shuffledIndex].options.length === updatedCard.options.length) {
										shuffledCards[shuffledIndex] = { ...updatedCard };
										// Find new index of the correct answer in shuffled options
										shuffledCards[shuffledIndex].correctOption = shuffledCards[shuffledIndex].options.findIndex(
											(opt) => opt === correctAnswer
										);
									} else {
										// If option count changed, just use the updated card
										shuffledCards[shuffledIndex] = { ...updatedCard };
									}
								} else {
									// For QA cards or type changes, just update
									shuffledCards[shuffledIndex] = { ...updatedCard };
								}
							}
						}

						showNotification('Card updated successfully!', 'success');
						saveToLocalStorage();
					}
				}

				function cancelEditing() {
					editingCardId = null;
					saveCardBtn.textContent = 'Add Card';
					formTitle.textContent = 'Add New Flashcard';
					cancelEditBtn.classList.add('hidden');
					resetForm();
				}

				function resetForm() {
					questionInput.value = '';
					// Does not clear the topic field. uncomment if you want to clear it
					//topicInput.value = '';
					answerInput.value = '';
					explanationInput.value = '';
					initializeOptionsContainer();
                    
                    // Do not reset card type - keep the current selection
				}

				function deleteCard(cardId) {
					if (confirm('Are you sure you want to delete this flashcard?')) {
						cards = cards.filter((card) => card.id !== cardId);
						renderCardList();

						// If we're in the view cards page, update that too
						if (currentPage === 'view') {
							renderTopicSections();
						}

						showNotification('Card deleted successfully!', 'success');

						if (editingCardId === cardId) {
							cancelEditing();
						}

						saveToLocalStorage();
					}
				}

				// Render the recent cards list in the Add Cards section
				function renderCardList() {
					cardListContainer.innerHTML = '';

					// Show only the 5 most recent cards
					const recentCards = [...cards].reverse().slice(0, 5);

					if (recentCards.length === 0) {
						const emptyMessage = document.createElement('div');
						emptyMessage.className = 'card-item';
						emptyMessage.style.textAlign = 'center';
						emptyMessage.style.color = '#6b7280';
						emptyMessage.textContent = 'No cards yet. Add your first card above!';
						cardListContainer.appendChild(emptyMessage);
						return;
					}

					recentCards.forEach((card, index) => {
						const cardItem = document.createElement('div');
						cardItem.className = 'card-item';

						const cardDetails = document.createElement('div');
						cardDetails.className = 'card-item-details';

						// Add topic tag if available
						if (card.topic && card.topic.trim() !== '') {
							const topicTag = document.createElement('div');
							topicTag.className = 'card-topic';
							topicTag.textContent = card.topic;
							cardDetails.appendChild(topicTag);
						}

						const cardTitle = document.createElement('h3');
						cardTitle.textContent = card.question;

						const cardType = document.createElement('p');
						cardType.textContent = card.type === 'qa' ? 'Question/Answer' : 'Multiple Choice';

						cardDetails.appendChild(cardTitle);
						cardDetails.appendChild(cardType);

						const cardActions = document.createElement('div');
						cardActions.className = 'card-item-actions';

						const editButton = document.createElement('button');
						editButton.className = 'btn-sm btn-blue-light';
						editButton.textContent = 'Edit';
						editButton.addEventListener('click', () => startEditing(card.id));

						const deleteButton = document.createElement('button');
						deleteButton.className = 'btn-sm btn-red-light';
						deleteButton.textContent = 'Delete';
						deleteButton.addEventListener('click', () => deleteCard(card.id));

						cardActions.appendChild(editButton);
						cardActions.appendChild(deleteButton);

						cardItem.appendChild(cardDetails);
						cardItem.appendChild(cardActions);

						cardListContainer.appendChild(cardItem);
					});

					if (cards.length > 5) {
						const viewMoreBtn = document.createElement('button');
						viewMoreBtn.className = 'btn-secondary btn-full mt-2';
						viewMoreBtn.textContent = `View All ${cards.length} Cards`;
						viewMoreBtn.addEventListener('click', () => {
							setCurrentPage('view');
							renderTopicSections();
						});
						cardListContainer.appendChild(viewMoreBtn);
					}
				}

				// Render all cards organized by topics
				function renderTopicSections() {
					topicSections.innerHTML = '';
					totalCardCount.textContent = cards.length;

					if (cards.length === 0) {
						const emptyMessage = document.createElement('div');
						emptyMessage.className = 'no-topics-message';
						emptyMessage.textContent = 'No flashcards yet. Add some cards to get started!';
						topicSections.appendChild(emptyMessage);
						return;
					}

					// Group cards by topic
					const cardsByTopic = {};

					// Add "No Topic" category
					cardsByTopic['No Topic'] = [];

					// Group cards by topic
					cards.forEach((card) => {
						const topic = card.topic && card.topic.trim() !== '' ? card.topic.trim() : 'No Topic';

						if (!cardsByTopic[topic]) {
							cardsByTopic[topic] = [];
						}

						cardsByTopic[topic].push(card);
					});

					// Sort topics alphabetically, but keep "No Topic" at the end
					const sortedTopics = Object.keys(cardsByTopic).sort((a, b) => {
						if (a === 'No Topic') return 1;
						if (b === 'No Topic') return -1;
						return a.localeCompare(b);
					});

					// Create sections for each topic
					sortedTopics.forEach((topic) => {
						if (cardsByTopic[topic].length === 0) return;

						const topicSection = document.createElement('div');
						topicSection.className = 'topic-section';

						const topicHeader = document.createElement('div');
						topicHeader.className = 'topic-header';

						const topicTitle = document.createElement('span');
						topicTitle.textContent = topic;
                        
                        const topicHeaderRight = document.createElement('div');
                        topicHeaderRight.className = 'topic-header-actions';

						const topicCount = document.createElement('span');
						topicCount.className = 'topic-header-count';
						topicCount.textContent = `${cardsByTopic[topic].length} card${cardsByTopic[topic].length !== 1 ? 's' : ''}`;
                        
                        // Add Quiz Topic button
                        if (topic !== 'No Topic') {
                            const quizTopicBtn = document.createElement('button');
                            quizTopicBtn.className = 'btn-sm btn-success';
                            quizTopicBtn.textContent = 'Quiz Topic';
                            quizTopicBtn.addEventListener('click', () => startQuiz(topic));
                            topicHeaderRight.appendChild(quizTopicBtn);
                        }
                        
                        topicHeaderRight.appendChild(topicCount);

						topicHeader.appendChild(topicTitle);
						topicHeader.appendChild(topicHeaderRight);

						const topicCards = document.createElement('div');
						topicCards.className = 'topic-cards';

						// Sort cards by question text
						cardsByTopic[topic].sort((a, b) => a.question.localeCompare(b.question));

						// Add cards to this topic section
						cardsByTopic[topic].forEach((card) => {
							const cardItem = document.createElement('div');
							cardItem.className = 'view-card-item';

							const cardQuestion = document.createElement('div');
							cardQuestion.className = 'view-card-question';
							cardQuestion.textContent = card.question;

							const cardType = document.createElement('div');
							cardType.className = 'view-card-type';

							const typeText = document.createElement('span');
							typeText.textContent = card.type === 'qa' ? 'Question/Answer' : 'Multiple Choice';

							const cardActions = document.createElement('div');
							cardActions.className = 'view-card-actions';

							const editButton = document.createElement('button');
							editButton.className = 'btn-sm btn-blue-light';
							editButton.textContent = 'Edit';
							editButton.addEventListener('click', () => {
								startEditing(card.id);
								setCurrentPage('add');
							});

							const deleteButton = document.createElement('button');
							deleteButton.className = 'btn-sm btn-red-light';
							deleteButton.textContent = 'Delete';
							deleteButton.addEventListener('click', () => deleteCard(card.id));

							cardActions.appendChild(editButton);
							cardActions.appendChild(deleteButton);

							cardType.appendChild(typeText);
							cardType.appendChild(cardActions);

							cardItem.appendChild(cardQuestion);
							cardItem.appendChild(cardType);

							topicCards.appendChild(cardItem);
						});

						topicSection.appendChild(topicHeader);
						topicSection.appendChild(topicCards);

						topicSections.appendChild(topicSection);
					});
				}

				function setCurrentPage(page) {
					currentPage = page;

					// Hide all sections first
					addCardSection.classList.add('hidden');
					viewCardsSection.classList.add('hidden');
					quizSection.classList.add('hidden');

					// Show the requested section
					if (page === 'add') {
						addCardSection.classList.remove('hidden');
					} else if (page === 'view') {
						viewCardsSection.classList.remove('hidden');
					} else if (page === 'quiz') {
						quizSection.classList.remove('hidden');
					}
                    
                    // Remove any topic-specific quiz header if we're not in quiz mode
                    if (page !== 'quiz') {
                        const topicHeader = document.querySelector('.quiz-topic-header');
                        if (topicHeader) {
                            topicHeader.remove();
                        }
                    }
				}
				function shuffleCardOptions(card) {
					if (card.type !== 'mc' || !card.options || card.options.length < 2) {
						return card; // Only shuffle MC cards with at least 2 options
					}

					// Store the correct answer value before shuffling
					const correctAnswer = card.options[card.correctOption];

					// Create copy of options array with their original indices
					const optionsWithIndices = card.options.map((option, index) => ({
						value: option,
						originalIndex: index,
					}));

					// Shuffle the array
					for (let i = optionsWithIndices.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[optionsWithIndices[i], optionsWithIndices[j]] = [optionsWithIndices[j], optionsWithIndices[i]];
					}

					// Update the card with shuffled options
					const shuffledCard = { ...card };
					shuffledCard.options = optionsWithIndices.map((item) => item.value);

					// Find new index of the correct answer
					shuffledCard.correctOption = shuffledCard.options.findIndex((opt) => opt === correctAnswer);

					return shuffledCard;
				}

				function startQuiz(selectedTopic = null) {
					if (cards.length === 0) {
						showNotification('Please add some flashcards first', 'error');
						return;
					}
                    
                    // Filter cards by topic if a topic is provided
                    let quizCards = selectedTopic 
                        ? cards.filter(card => card.topic === selectedTopic) 
                        : [...cards];
                    
                    if (quizCards.length === 0) {
                        showNotification(`No cards found for topic: ${selectedTopic}`, 'error');
                        return;
                    }

					// Create a copy of cards for the quiz
					shuffledCards = quizCards.map((card) => {
						// For MC cards, shuffle the options
						if (card.type === 'mc') {
							return shuffleCardOptions({ ...card });
						}
						return { ...card };
					});

					// Shuffle the order of cards only if randomize is checked
                    if (randomizeCardsCheckbox.checked) {
                        for (let i = shuffledCards.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [shuffledCards[i], shuffledCards[j]] = [shuffledCards[j], shuffledCards[i]];
                        }
                    }

					currentCardIndex = 0;
					showAnswer = false;
					selectedOption = null;

					// Reset quiz statistics
					quizStats = {
						cardsReviewed: 0,
						startTime: new Date(),
						cardsTimes: [],
					};

					updateProgressBar();
					setCurrentPage('quiz');
					renderQuizCard();
                    
                    // Add topic info to quiz header if we're doing a topic-specific quiz
                    if (selectedTopic) {
                        const quizHeader = document.createElement('div');
                        quizHeader.className = 'quiz-topic-header';
                        quizHeader.innerHTML = `<h3>Topic: ${selectedTopic}</h3>`;
                        quizSection.insertBefore(quizHeader, quizSection.firstChild);
                    }
				}

				function updateProgressBar() {
					const progress = (currentCardIndex / shuffledCards.length) * 100;
					progressBar.style.width = `${progress}%`;
				}

				function renderQuizCard() {
					if (shuffledCards.length === 0) return;

					updateProgressBar();

					const card = shuffledCards[currentCardIndex];
					quizCardContainer.innerHTML = '';

					const cardElement = document.createElement('div');
					cardElement.className = 'quiz-card';

					// Add edit button
					const editButton = document.createElement('button');
					editButton.className = 'quiz-edit-button';
					editButton.textContent = 'Edit Card';
					editButton.addEventListener('click', editCurrentQuizCard);
					cardElement.appendChild(editButton);

					const cardHeader = document.createElement('div');
					cardHeader.className = 'quiz-card-header';
					cardHeader.textContent = `Card ${currentCardIndex + 1} of ${shuffledCards.length}`;

					// Display topic if available
					if (card.topic && card.topic.trim() !== '') {
						const topicElement = document.createElement('div');
						topicElement.className = 'quiz-card-topic';
						topicElement.textContent = card.topic;
						cardElement.appendChild(topicElement);
					}

					const cardQuestion = document.createElement('div');
					cardQuestion.className = 'quiz-card-question';
					cardQuestion.textContent = card.question;

					cardElement.appendChild(cardHeader);
					cardElement.appendChild(cardQuestion);

					if (card.type === 'qa') {
						// QA card
						if (showAnswer) {
							const answerSection = document.createElement('div');
							answerSection.className = 'answer-section';

							const answerTitle = document.createElement('p');
							answerTitle.textContent = 'Answer:';

							const answerText = document.createElement('p');
							answerText.textContent = card.answer;

							answerSection.appendChild(answerTitle);
							answerSection.appendChild(answerText);
							cardElement.appendChild(answerSection);

							// Navigation buttons (when answer is shown)
							addNavigationButtons(cardElement);
						} else {
							const showAnswerButton = document.createElement('button');
							showAnswerButton.className = 'btn-primary btn-full btn-show-answer';
							showAnswerButton.textContent = 'Show Answer';
							showAnswerButton.addEventListener('click', () => {
								showAnswer = true;
								renderQuizCard();

								// Record card review in stats
								recordCardReview();
							});

							cardElement.appendChild(showAnswerButton);

							// Navigation buttons (when answer is not shown)
							addNavigationButtons(cardElement, true);
						}
					} else {
						// MC card
						const optionsContainer = document.createElement('div');
						optionsContainer.className = 'space-y-2';

						card.options.forEach((option, idx) => {
							const optionElement = document.createElement('div');
							optionElement.className = 'quiz-option';
							optionElement.textContent = option;

							if (showAnswer) {
								if (idx === card.correctOption) {
									optionElement.classList.add('correct');
								} else if (idx === selectedOption && idx !== card.correctOption) {
									optionElement.classList.add('incorrect');
								}
							} else {
								optionElement.addEventListener('click', () => {
									selectedOption = idx;
									showAnswer = true;
									renderQuizCard();

									// Record card review in stats
									recordCardReview();
								});
							}

							optionsContainer.appendChild(optionElement);
						});

						cardElement.appendChild(optionsContainer);

						if (showAnswer && card.explanation) {
							const answerSection = document.createElement('div');
							answerSection.className = 'answer-section';

							const explanationTitle = document.createElement('p');
							explanationTitle.textContent = 'Explanation:';

							const explanationText = document.createElement('p');
							explanationText.textContent = card.explanation;

							answerSection.appendChild(explanationTitle);
							answerSection.appendChild(explanationText);
							cardElement.appendChild(answerSection);
						}

						if (!showAnswer) {
							const showAnswerButton = document.createElement('button');
							showAnswerButton.className = 'btn-primary btn-full btn-show-answer';
							showAnswerButton.textContent = 'Show Answer';
							showAnswerButton.addEventListener('click', () => {
								showAnswer = true;
								renderQuizCard();

								// Record card review in stats
								recordCardReview();
							});

							cardElement.appendChild(showAnswerButton);

							// Navigation buttons (when answer is not shown)
							addNavigationButtons(cardElement, true);
						} else {
							// Navigation buttons (when answer is shown)
							addNavigationButtons(cardElement);
						}
					}

					// Return to cards button
					const returnButton = document.createElement('button');
					returnButton.className = 'btn-secondary btn-full mt-4';
					returnButton.textContent = 'Return to Cards';
					returnButton.addEventListener('click', () => {
						// Show quiz summary if completed cards
						if (quizStats.cardsReviewed > 0) {
							showQuizSummary();
						}

						setCurrentPage('add');
					});

					cardElement.appendChild(returnButton);

					quizCardContainer.appendChild(cardElement);
				}

				function recordCardReview() {
					quizStats.cardsReviewed++;
					quizStats.cardsTimes.push(new Date());
				}

				function showQuizSummary() {
					// Create a quiz summary element
					const summaryElement = document.createElement('div');
					summaryElement.className = 'quiz-stats';

					const title = document.createElement('h3');
					title.textContent = 'Quiz Session Summary';

					const cardsReviewed = document.createElement('p');
					cardsReviewed.textContent = `Cards reviewed: ${quizStats.cardsReviewed} of ${shuffledCards.length}`;

					// Calculate time spent
					let timeSpent = 'N/A';
					if (quizStats.startTime && quizStats.cardsTimes.length > 0) {
						const endTime = quizStats.cardsTimes[quizStats.cardsTimes.length - 1];
						const totalSeconds = Math.round((endTime - quizStats.startTime) / 1000);

						if (totalSeconds < 60) {
							timeSpent = `${totalSeconds} seconds`;
						} else {
							const minutes = Math.floor(totalSeconds / 60);
							const seconds = totalSeconds % 60;
							timeSpent = `${minutes} minute${minutes !== 1 ? 's' : ''} ${seconds} second${seconds !== 1 ? 's' : ''}`;
						}
					}

					const timeSpentElement = document.createElement('p');
					timeSpentElement.textContent = `Time spent: ${timeSpent}`;

					// Append all elements to the summary
					summaryElement.appendChild(title);
					summaryElement.appendChild(cardsReviewed);
					summaryElement.appendChild(timeSpentElement);

					// Create a modal-like container for the summary
					const modalOverlay = document.createElement('div');
					modalOverlay.className = 'modal-overlay';
					modalOverlay.style.opacity = '1';

					const modalContent = document.createElement('div');
					modalContent.className = 'modal-content';

					// Add a close button
					const closeButton = document.createElement('button');
					closeButton.className = 'btn-primary btn-full mt-4';
					closeButton.textContent = 'Continue';
					closeButton.addEventListener('click', () => {
						document.body.removeChild(modalOverlay);
					});

					// Also allow clicking outside the modal to close it
					modalOverlay.addEventListener('click', function (e) {
						if (e.target === modalOverlay) {
							document.body.removeChild(modalOverlay);
						}
					});

					// Assemble the modal
					modalContent.appendChild(summaryElement);
					modalContent.appendChild(closeButton);
					modalOverlay.appendChild(modalContent);

					// Add to the document
					document.body.appendChild(modalOverlay);
				}

				function addNavigationButtons(cardElement, skipAnswerMode = false) {
					const navigationContainer = document.createElement('div');
					navigationContainer.className = 'navigation-buttons';

					// Previous button
					const prevButton = document.createElement('button');
					prevButton.className = 'btn-secondary';
					prevButton.textContent = '← Previous';
					prevButton.disabled = currentCardIndex === 0;
					prevButton.addEventListener('click', () => {
						previousCard();
					});

					// Next button or Finish button
					const nextButton = document.createElement('button');

					if (currentCardIndex === shuffledCards.length - 1) {
						// This is the last card, use Finish button
						nextButton.className = 'btn-primary';
						nextButton.textContent = 'Finish';
						nextButton.addEventListener('click', () => {
							// Show quiz summary
							showQuizSummary();
							// Return to cards view
							setCurrentPage('add');
						});
					} else {
						// Regular next button
						nextButton.className = 'btn-success';
						nextButton.textContent = 'Next →';
						nextButton.addEventListener('click', () => {
							nextCard();
						});
					}

					navigationContainer.appendChild(prevButton);
					navigationContainer.appendChild(nextButton);

					if (skipAnswerMode) {
						// If we're in the mode where answer is not shown yet, put nav buttons below the show answer button
						cardElement.appendChild(navigationContainer);
					} else {
						// If answer is already shown, insert navigation buttons before the last element (which would be "Return to Cards" button)
						cardElement.insertBefore(navigationContainer, cardElement.lastChild);
					}
				}

				function nextCard() {
					if (currentCardIndex < shuffledCards.length - 1) {
						currentCardIndex++;
						showAnswer = false;
						selectedOption = null;
						renderQuizCard();
					} else {
						showNotification('You are at the last card!', 'info');
					}
				}

				function previousCard() {
					if (currentCardIndex > 0) {
						currentCardIndex--;
						showAnswer = false;
						selectedOption = null;
						renderQuizCard();
					} else {
						showNotification('You are at the first card!', 'info');
					}
				}

				function handleKeyboardShortcuts(event) {
					// Only process keyboard shortcuts when in quiz mode
					if (currentPage !== 'quiz') return;

					// Skip shortcuts if modal is open
					const modalOpen = document.querySelector('.modal-overlay:not(.hidden)');
					if (modalOpen) return;

					switch (event.key) {
						case ' ': // Space key
							// Toggle answer visibility
							if (!showAnswer) {
								showAnswer = true;
								recordCardReview();
								renderQuizCard();
							}
							event.preventDefault(); // Prevent scrolling
							break;
						case 'ArrowRight': // Right arrow
							nextCard();
							event.preventDefault();
							break;
						case 'ArrowLeft': // Left arrow
							previousCard();
							event.preventDefault();
							break;
					}
				}

				function showClearConfirmation() {
					if (cards.length === 0) {
						showNotification('No cards to clear', 'info');
						return;
					}

					clearConfirmModal.classList.remove('hidden');
				}

				function hideClearConfirmation() {
					clearConfirmModal.classList.add('hidden');
				}

				function clearAllCards() {
					cards = [];
					renderCardList();

					// If we're in the view cards page, update that too
					if (currentPage === 'view') {
						renderTopicSections();
					}

					saveToLocalStorage();
					hideClearConfirmation();
					showNotification('All cards have been cleared', 'success');
				}

				function exportThenClear() {
					exportCards(true);
					hideClearConfirmation();
				}

				function showNotification(message, type = 'info') {
					// Remove any existing notification
					const existingNotification = document.querySelector('.notification');
					if (existingNotification) {
						existingNotification.remove();
					}

					const notification = document.createElement('div');
					notification.className = `notification ${type}`;
					notification.textContent = message;

					document.body.appendChild(notification);

					// Make notification visible
					setTimeout(() => {
						notification.style.opacity = '1';
					}, 10);

					// Auto remove after 3 seconds
					setTimeout(() => {
						notification.style.opacity = '0';
						setTimeout(() => {
							notification.remove();
						}, 300);
					}, 3000);
				}

				// Import/Export Functions
				function importCards(event) {
					const file = event.target.files[0];
					if (!file) return;

					const reader = new FileReader();

					reader.onload = (e) => {
						try {
							const text = e.target.result;

							// Check file extension
							if (file.name.endsWith('.csv')) {
								parseCSV(text);
							} else if (file.name.endsWith('.txt')) {
								parseTXT(text);
							} else if (file.name.endsWith('.json')) {
								parseJSON(text);
							} else {
								showNotification('Unsupported file format. Please use CSV, TXT, or JSON.', 'error');
							}
						} catch (error) {
							showNotification('Error importing file: ' + error.message, 'error');
						}
					};

					reader.readAsText(file);
					// Reset file input
					event.target.value = '';
				}

				function parseCSV(text) {
					// Split by lines
					const lines = text.split('\n').filter((line) => line.trim() !== '');

					if (lines.length <= 1) {
						showNotification('CSV file is empty or has only headers', 'error');
						return;
					}

					// Check header
					const header = lines[0].toLowerCase();
					if (!header.includes('question')) {
						showNotification('CSV file must have a question column', 'error');
						return;
					}

					const newCards = [];
					const hasType = header.includes('type');
					const hasTopic = header.includes('topic');

					// Helper function to restore newlines from \\n sequences
					const restoreNewlines = (str) => {
						if (!str) return str;
						return str.replace(/\\n/g, '\n');
					};

					// Skip header row
					for (let i = 1; i < lines.length; i++) {
						try {
							// CSV parsing
							const parts = parseCSVLine(lines[i]);

							if (parts.length < 2) continue;

							let cardType = 'qa';
							let topicIndex = -1;
							let questionIndex = 0;
							let answerIndex = 1;
							let optionsIndex = -1;
							let correctOptionIndex = -1;
							let explanationIndex = -1;

							// Determine indices based on header
							const headers = parseCSVLine(lines[0]).map((h) => h.toLowerCase());

							if (hasType) {
								cardType = parts[headers.indexOf('type')] === 'mc' ? 'mc' : 'qa';
								topicIndex = headers.indexOf('topic');
								questionIndex = headers.indexOf('question');
								answerIndex = headers.indexOf('answer');
								optionsIndex = headers.indexOf('options');
								correctOptionIndex = headers.indexOf('correctoption');
								explanationIndex = headers.indexOf('explanation');
							}

							// Create card with newlines restored
							const newCard = {
								id: Date.now() + i,
								question: restoreNewlines(parts[questionIndex]) || 'No question provided',
								type: cardType,
								topic: topicIndex >= 0 && topicIndex < parts.length ? parts[topicIndex] : '',
							};

							if (cardType === 'qa') {
								newCard.answer = answerIndex >= 0 && answerIndex < parts.length ? 
                                    restoreNewlines(parts[answerIndex]) : 'No answer provided';
							} else {
								const optionsStr = optionsIndex >= 0 && optionsIndex < parts.length ? parts[optionsIndex] : '';
								// Restore newlines in each option
								newCard.options = optionsStr.split('|')
                                    .map(opt => restoreNewlines(opt))
                                    .filter((opt) => opt.trim() !== '');

								if (newCard.options.length < 2) {
									newCard.options = ['Option 1', 'Option 2'];
								}

								newCard.correctOption =
									correctOptionIndex >= 0 && correctOptionIndex < parts.length ? parseInt(parts[correctOptionIndex]) || 0 : 0;

								if (newCard.correctOption >= newCard.options.length) {
									newCard.correctOption = 0;
								}

								newCard.explanation = explanationIndex >= 0 && explanationIndex < parts.length ? 
                                    restoreNewlines(parts[explanationIndex]) : '';
							}

							newCards.push(newCard);
						} catch (e) {
							console.error('Error parsing line', i, e);
							// Continue with other lines
						}
					}

					if (newCards.length === 0) {
						showNotification('No valid cards found in the file', 'error');
						return;
					}

					cards = [...cards, ...newCards];
					renderCardList();
					saveToLocalStorage();
					showNotification(`Imported ${newCards.length} cards successfully!`, 'success');
				}

				function parseCSVLine(line) {
					const result = [];
					let current = '';
					let inQuotes = false;

					for (let i = 0; i < line.length; i++) {
						const char = line[i];

						if (char === '"') {
							if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
								// Escaped quote
								current += '"';
								i++; // Skip next quote
							} else {
								// Toggle quotes mode
								inQuotes = !inQuotes;
							}
						} else if (char === ',' && !inQuotes) {
							// End of field
							result.push(current);
							current = '';
						} else {
							current += char;
						}
					}

					// Add the last field
					result.push(current);
					return result;
				}

				function parseTXT(text) {
					const lines = text.split('\n');
					const newCards = [];

					let currentQuestion = '';
					let currentAnswer = '';
					let currentTopic = '';
					let topicFound = false;
                    
                    // Helper function to restore newlines from \\n sequences
					const restoreNewlines = (str) => {
						if (!str) return str;
						return str.replace(/\\n/g, '\n');
					};

					for (let i = 0; i < lines.length; i++) {
						const line = lines[i].trim();

						if (line.startsWith('T:') || line.startsWith('Topic:')) {
							currentTopic = line.substring(line.indexOf(':') + 1).trim();
							topicFound = true;
						} else if (line.startsWith('Q:') || line.startsWith('Question:')) {
							// Save previous QA pair if exists
							if (currentQuestion && currentAnswer) {
								newCards.push({
									id: Date.now() + newCards.length,
									type: 'qa',
									topic: currentTopic,
									question: restoreNewlines(currentQuestion),
									answer: restoreNewlines(currentAnswer),
								});

								// Reset for next card
								if (!topicFound) {
									currentTopic = '';
								}
								topicFound = false;
							}

							// Start new question
							currentQuestion = line.substring(line.indexOf(':') + 1).trim();
							currentAnswer = '';
						} else if (line.startsWith('A:') || line.startsWith('Answer:')) {
							currentAnswer = line.substring(line.indexOf(':') + 1).trim();
						} else if (currentQuestion && line) {
							// Append to current answer if we're in an answer section
							if (currentAnswer) {
								currentAnswer += '\n' + line;
							} else {
								// If no answer marker found yet, assume it's part of the question
								currentQuestion += '\n' + line;
							}
						}
					}

					// Add the last QA pair
					if (currentQuestion && currentAnswer) {
						newCards.push({
							id: Date.now() + newCards.length,
							type: 'qa',
							topic: currentTopic,
							question: restoreNewlines(currentQuestion),
							answer: restoreNewlines(currentAnswer),
						});
					}

					if (newCards.length === 0) {
						showNotification('No valid cards found in the text file', 'error');
						return;
					}

					cards = [...cards, ...newCards];
					renderCardList();
					saveToLocalStorage();
					showNotification(`Imported ${newCards.length} cards successfully!`, 'success');
				}

				function parseJSON(text) {
					try {
						const data = JSON.parse(text);

						if (!Array.isArray(data)) {
							showNotification('JSON file must contain an array of cards', 'error');
							return;
						}
                        
                        // Helper function to restore newlines from \\n sequences
						const restoreNewlines = (str) => {
							if (!str) return str;
							return str.replace(/\\n/g, '\n');
						};

						const newCards = data
							.filter((card) => {
								return card && typeof card === 'object' && typeof card.question === 'string' && (card.type === 'qa' || card.type === 'mc');
							})
							.map((card, index) => ({
								id: Date.now() + index,
								question: restoreNewlines(card.question),
								type: card.type,
								topic: card.topic || '',
								...(card.type === 'qa'
									? { answer: restoreNewlines(card.answer) || 'No answer provided' }
									: {
											options: Array.isArray(card.options) 
                                                ? card.options.map(opt => restoreNewlines(opt)) 
                                                : ['Option 1', 'Option 2'],
											correctOption: typeof card.correctOption === 'number' ? card.correctOption : 0,
											explanation: restoreNewlines(card.explanation) || '',
									  }),
							}));

						if (newCards.length === 0) {
							showNotification('No valid cards found in the JSON file', 'error');
							return;
						}

						cards = [...cards, ...newCards];
						renderCardList();
						saveToLocalStorage();
						showNotification(`Imported ${newCards.length} cards successfully!`, 'success');
					} catch (e) {
						showNotification('Invalid JSON format: ' + e.message, 'error');
					}
				}

				function exportCards(clearAfterExport = false) {
					if (cards.length === 0) {
						showNotification('No cards to export', 'error');
						return;
					}

					let csvContent = cardsToCSV();
					downloadFile(csvContent, 'flashcards.csv', 'text/csv');
					showNotification('Cards exported successfully!', 'success');

					// Only show clear prompt if explicitly requested
					if (clearAfterExport) {
                        // Create a modal for confirmation
                        const modalOverlay = document.createElement('div');
                        modalOverlay.className = 'modal-overlay';
                        modalOverlay.style.opacity = '1';

                        const modalContent = document.createElement('div');
                        modalContent.className = 'modal-content';

                        const title = document.createElement('h3');
                        title.className = 'modal-title';
                        title.textContent = 'Clear All Flashcards';

                        const message = document.createElement('p');
                        message.className = 'modal-message';
                        message.textContent = 'Your flashcards have been exported. Do you want to clear all cards now?';

                        const buttonContainer = document.createElement('div');
                        buttonContainer.className = 'modal-actions';

                        const confirmButton = document.createElement('button');
                        confirmButton.className = 'btn-danger';
                        confirmButton.textContent = 'Yes, Clear All Cards';
                        confirmButton.addEventListener('click', () => {
                            clearAllCards();
                            document.body.removeChild(modalOverlay);
                        });

                        const cancelButton = document.createElement('button');
                        cancelButton.className = 'btn-secondary';
                        cancelButton.textContent = 'No, Keep My Cards';
                        cancelButton.addEventListener('click', () => {
                            document.body.removeChild(modalOverlay);
                        });

                        buttonContainer.appendChild(confirmButton);
                        buttonContainer.appendChild(cancelButton);
                        
                        modalContent.appendChild(title);
                        modalContent.appendChild(message);
                        modalContent.appendChild(buttonContainer);
                        modalOverlay.appendChild(modalContent);

                        // Add to the document
                        document.body.appendChild(modalOverlay);
                        
                        // Also allow clicking outside the modal to close it (which means "keep cards")
                        modalOverlay.addEventListener('click', function(e) {
                            if (e.target === modalOverlay) {
                                document.body.removeChild(modalOverlay);
                            }
                        });
					}
				}

				function downloadFile(content, fileName, contentType) {
					const blob = new Blob([content], { type: contentType });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = fileName;
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
				}

				// Local Storage functions
				function saveToLocalStorage() {
					try {
						localStorage.setItem('flashcards', JSON.stringify(cards));
						lastAutoSaveTime = new Date();
						updateAutoSaveIndicator();
						return true;
					} catch (e) {
						console.error('Error saving to localStorage:', e);
						return false;
					}
				}

				function loadFromLocalStorage() {
					try {
						const savedCards = localStorage.getItem('flashcards');
						if (savedCards) {
							cards = JSON.parse(savedCards);
							renderCardList();
							totalCardCount.textContent = cards.length;
							lastAutoSaveTime = new Date();
							updateAutoSaveIndicator();
							showNotification('Cards loaded from previous session', 'info');
						}
					} catch (e) {
						console.error('Error loading from localStorage:', e);
					}
				}

				function updateAutoSaveIndicator() {
					if (lastAutoSaveTime) {
						const now = new Date();
						const timeDiff = Math.floor((now - lastAutoSaveTime) / 1000); // in seconds

						if (timeDiff < 60) {
							autosaveIndicator.textContent = `Saved ${timeDiff} seconds ago`;
						} else if (timeDiff < 3600) {
							const minutes = Math.floor(timeDiff / 60);
							autosaveIndicator.textContent = `Saved ${minutes} minute${minutes > 1 ? 's' : ''} ago`;
						} else {
							const hours = Math.floor(timeDiff / 3600);
							autosaveIndicator.textContent = `Saved ${hours} hour${hours > 1 ? 's' : ''} ago`;
						}
					} else {
						autosaveIndicator.textContent = '';
					}
				}

				function cardsToCSV() {
					let csvContent = 'type,topic,question,answer,options,correctOption,explanation\n';

					cards.forEach((card) => {
						let row = '';
						row += `${card.type},`;
						row += `"${(card.topic || '').replace(/"/g, '""')}",`;
						
						// Replace newlines in question with \\n
						const escapedQuestion = card.question.replace(/\n/g, '\\n').replace(/"/g, '""');
						row += `"${escapedQuestion}",`;

						if (card.type === 'qa') {
							// Replace newlines in answer with \\n
							const escapedAnswer = card.answer.replace(/\n/g, '\\n').replace(/"/g, '""');
							row += `"${escapedAnswer}",,,`;
						} else {
							row += `,`;
							
							// Replace newlines in options
							const escapedOptions = card.options.map(opt => opt.replace(/\n/g, '\\n').replace(/"/g, '""')).join('|');
							row += `"${escapedOptions}",`;
							
							row += `${card.correctOption},`;
							
							// Replace newlines in explanation
							const escapedExplanation = (card.explanation || '').replace(/\n/g, '\\n').replace(/"/g, '""');
							row += `"${escapedExplanation}"`;
						}

						csvContent += row + '\n';
					});

					return csvContent;
				}

				// Set up a timer to update the last-saved time display
				setInterval(updateAutoSaveIndicator, 30000); // Update every 30 seconds

				// ESC key to close modals
				document.addEventListener('keydown', function (e) {
					if (e.key === 'Escape') {
						// Close any open modals
						if (!clearConfirmModal.classList.contains('hidden')) {
							hideClearConfirmation();
						}

						if (!editCardModal.classList.contains('hidden')) {
							hideEditCardModal();
						}

						// Close any quiz summary modals
						const openModals = document.querySelectorAll('.modal-overlay');
						openModals.forEach((modal) => {
							if (modal !== clearConfirmModal) {
								document.body.removeChild(modal);
							}
						});
					}
				});

				// Make sure modal is hidden initially
				if (clearConfirmModal) {
					clearConfirmModal.classList.add('hidden');
				}

				// Initialize modal options container
				initializeModalOptionsContainer();

				// Update grid size when dropdown changes
				gridSizeSelect.addEventListener('change', function() {
					topicSections.style.gridTemplateColumns = `repeat(${this.value}, 1fr)`;
				});

				// Initialize the app
				renderCardList();
			});
		</script>
	</body>
</html>
